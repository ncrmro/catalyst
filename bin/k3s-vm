#!/usr/bin/env python3
"""
K3s VM Management Script (NixOS-native)

Creates a local K3s development VM using NixOS configuration and QEMU.
Zero external dependencies beyond Nix.
"""

import argparse
import os
import signal
import subprocess
import sys
import time
from pathlib import Path

# ============================================================================
# Configuration
# ============================================================================

SCRIPT_DIR = Path(__file__).parent.resolve()
PROJECT_ROOT = SCRIPT_DIR.parent

# Paths
CONFIG_DIR = PROJECT_ROOT / ".k3s-vm"
VM_DIR = CONFIG_DIR / "vm"
KUBECONFIG_DIR = PROJECT_ROOT / "web" / ".kube"
KUBECONFIG_FILE = KUBECONFIG_DIR / "config"
PID_FILE = CONFIG_DIR / "vm.pid"

# VM settings
DEFAULT_VM_MEMORY = 8192
DEFAULT_VM_CORES = 4

# Manifests directory
MANIFESTS_DIR = CONFIG_DIR / "manifests"
BASE_MANIFEST = MANIFESTS_DIR / "base.json"

# NixOS configuration template for K3s VM
NIXOS_CONFIG_TEMPLATE = '''
{{ config, pkgs, lib, ... }}:
{{
  # Boot configuration for VM
  boot.loader.systemd-boot.enable = true;
  boot.loader.efi.canTouchEfiVariables = true;

  # Networking
  networking.hostName = "k3s-vm";
  networking.firewall.enable = false;

  # Disable audio
  sound.enable = false;
  services.pipewire.enable = false;
  hardware.pulseaudio.enable = false;

  # Enable SSH
  services.openssh = {{
    enable = true;
    settings.PermitRootLogin = "yes";
  }};

  # K3s service
  services.k3s = {{
    enable = true;
    role = "server";
    extraFlags = toString [
      "--disable=traefik"
      "--write-kubeconfig-mode=644"
    ];
  }};

  systemd.services.k3s.postStart = ''
    until [ -f /etc/rancher/k3s/k3s.yaml ]; do sleep 1; done
    cp /etc/rancher/k3s/k3s.yaml /var/kubeconfig
    chmod 644 /var/kubeconfig
  '' ;

  # Root user with SSH key
  users.users.root = {{
    openssh.authorizedKeys.keys = [
      "{ssh_public_key}"
    ];
  }};

  # Useful packages
  environment.systemPackages = with pkgs; [
    kubectl
    k9s
    vim
    curl
    htop
  ];

  # Auto-login for console access (optional, for debugging)
  services.getty.autologinUser = "root";

  # VM-specific settings
  virtualisation.vmVariant = {{
    virtualisation.memorySize = {memory};
    virtualisation.cores = {cores};
    virtualisation.diskSize = 40960;
    virtualisation.graphics = false;

    virtualisation.sharedDirectories = {{
      code = {{
        source = "{project_root}";
        target = "/code";
      }};
    }};

    # Forward ports for K3s API and SSH
    virtualisation.forwardPorts = [
{forward_ports}
    ];
  }};

  system.stateVersion = "24.05";
}}
'''


def run(cmd: list[str], check: bool = True, capture: bool = False, **kwargs) -> subprocess.CompletedProcess:
    """Run a command and return result."""
    if capture:
        kwargs.setdefault("stdout", subprocess.PIPE)
        kwargs.setdefault("stderr", subprocess.PIPE)
        kwargs.setdefault("text", True)
    return subprocess.run(cmd, check=check, **kwargs)


def error(msg: str) -> None:
    """Print error and exit."""
    print(f"ERROR: {msg}", file=sys.stderr)
    sys.exit(1)


def info(msg: str) -> None:
    """Print info message."""
    print(f"  {msg}")


def debug(msg: str) -> None:
    """Print debug message (only if verbose)."""
    # Silent by default, can be enabled with environment variable
    if os.environ.get("K3S_VM_DEBUG"):
        print(f"  [debug] {msg}")


def get_web_port() -> int | None:
    """Get PORT from web/.env."""
    env_file = PROJECT_ROOT / "web" / ".env"
    if not env_file.exists():
        return None
    
    try:
        content = env_file.read_text()
        for line in content.splitlines():
            line = line.strip()
            if line.startswith("WEB_PORT="):
                return int(line.split("=", 1)[1])
    except (ValueError, IndexError):
        pass
    return None

def get_web_env_vars() -> list[dict]:
    """Reads web/.env and returns list of env var dicts for Kubernetes.

    Excludes KUBECONFIG and KUBECONFIG_PRIMARY since pods should use
    in-cluster authentication via service account tokens.
    """
    env_file = PROJECT_ROOT / "web" / ".env"
    if not env_file.exists():
        return []

    # Env vars to exclude - pods use in-cluster auth via service account
    excluded_vars = {"KUBECONFIG", "KUBECONFIG_PRIMARY"}

    env_vars = []
    try:
        content = env_file.read_text()
        for line in content.splitlines():
            line = line.strip()
            if not line or line.startswith('#') or '=' not in line:
                continue

            key, value = line.split('=', 1)

            # Skip excluded env vars
            if key in excluded_vars:
                debug(f"Excluding env var {key} (using in-cluster auth)")
                continue

            # Remove surrounding quotes if present
            if (value.startswith('"') and value.endswith('"')) or (value.startswith("'" ) and value.endswith("'" )):
                value = value[1:-1]

            env_vars.append({"name": key, "value": value})

    except Exception as e:
        debug(f"Error parsing .env: {e}")
        return []

    return env_vars


def get_ssh_public_key() -> str:
    """Get or generate SSH public key."""
    ssh_key = Path.home() / ".ssh" / "id_rsa"
    ssh_pub = ssh_key.with_suffix(".pub")

    if not ssh_pub.exists():
        if not ssh_key.parent.exists():
            ssh_key.parent.mkdir(mode=0o700)
        print("Generating SSH key...")
        run(["ssh-keygen", "-t", "rsa", "-b", "4096", "-N", "", "-f", str(ssh_key)])

    return ssh_pub.read_text().strip()


def is_vm_running() -> bool:
    """Check if VM process is running."""
    if not PID_FILE.exists():
        return False

    try:
        pid = int(PID_FILE.read_text().strip())
        os.kill(pid, 0)  # Check if process exists
        return True
    except (ProcessLookupError, ValueError):
        PID_FILE.unlink(missing_ok=True)
        return False


def get_vm_pid() -> int | None:
    """Get VM process PID."""
    if not PID_FILE.exists():
        return None
    try:
        return int(PID_FILE.read_text().strip())
    except ValueError:
        return None


def wait_for_ssh(timeout: int = 120) -> bool:
    """Wait for SSH to become available."""
    start = time.time()
    while time.time() - start < timeout:
        try:
            result = run(
                ["ssh", "-o", "StrictHostKeyChecking=no", "-o", "UserKnownHostsFile=/dev/null", "-o", "ConnectTimeout=5",
                 "-o", "BatchMode=yes", "-p", "2666", "root@localhost", "true"],
                capture=True, check=False
            )
            if result.returncode == 0:
                return True
            debug(f"SSH check failed (code {result.returncode}): {result.stderr.strip()}")
        except Exception as e:
            debug(f"SSH check error: {e}")
            pass
        time.sleep(2)
    return False


def wait_for_k3s(timeout: int = 300) -> bool:
    """Wait for K3s API to become available."""
    start = time.time()
    while time.time() - start < timeout:
        try:
            result = run(
                ["ssh", "-o", "StrictHostKeyChecking=no", "-o", "UserKnownHostsFile=/dev/null", "-p", "2666",
                 "root@localhost", "kubectl --kubeconfig /etc/rancher/k3s/k3s.yaml get nodes"],
                capture=True, check=False
            )
            if result.returncode == 0 and "Ready" in result.stdout:
                return True
            
            debug(f"K3s check failed (code {result.returncode})")
            if result.stdout: debug(f"stdout: {result.stdout.strip()}")
            if result.stderr: debug(f"stderr: {result.stderr.strip()}")
        except Exception as e:
            debug(f"K3s check error: {e}")
            pass
        time.sleep(3)
    return False


def extract_kubeconfig() -> bool:
    """Extract kubeconfig from VM and update .env for integration tests."""
    try:
        result = run(
            ["ssh", "-o", "StrictHostKeyChecking=no", "-o", "UserKnownHostsFile=/dev/null", "-p", "2666",
             "root@localhost", "cat /etc/rancher/k3s/k3s.yaml"],
            capture=True
        )

        # Replace localhost with 127.0.0.1:6443 (forwarded port)
        kubeconfig = result.stdout.replace("127.0.0.1:6443", "127.0.0.1:6443")
        kubeconfig = kubeconfig.replace("https://127.0.0.1", "https://127.0.0.1")

        KUBECONFIG_DIR.mkdir(parents=True, exist_ok=True)
        KUBECONFIG_FILE.write_text(kubeconfig)

        # Create a symlink in the web root for easier access/CLI usage
        # web/kubeconfig.yaml -> .kube/config
        web_root = PROJECT_ROOT / "web"
        symlink_path = web_root / "kubeconfig.yaml"
        target_path = Path(".kube/config") # Relative to web/
        
        # Atomic replacement of symlink
        if symlink_path.exists() or symlink_path.is_symlink():
            symlink_path.unlink()
        symlink_path.symlink_to(target_path)
        info("Created symlink web/kubeconfig.yaml -> .kube/config")

        # Also update .env with base64-encoded JSON kubeconfig for integration tests
        update_env_kubeconfig(kubeconfig)

        return True
    except subprocess.CalledProcessError:
        return False


def update_env_kubeconfig(kubeconfig_yaml: str) -> None:
    """Update KUBECONFIG_PRIMARY and KUBECONFIG in web/.env."""
    import base64
    import json
    import re

    env_file = PROJECT_ROOT / "web" / ".env"
    # Ensure web/.env exists
    if not env_file.exists():
        env_file.write_text("")

    # Convert YAML to JSON using node (available in web directory)
    try:
        result = run(
            ["node", "-e", f"""
const yaml = require('yaml');
const kubeconfig = yaml.parse({json.dumps(kubeconfig_yaml)});
console.log(JSON.stringify(kubeconfig));
"""],
            capture=True,
            cwd=PROJECT_ROOT / "web"
        )
        kubeconfig_json = result.stdout.strip()
        kubeconfig_b64 = base64.b64encode(kubeconfig_json.encode()).decode()

        env_content = env_file.read_text()
        
        # Update KUBECONFIG_PRIMARY
        if "KUBECONFIG_PRIMARY=" in env_content:
            env_content = re.sub(
                r'^KUBECONFIG_PRIMARY=.*$',
                f'KUBECONFIG_PRIMARY={kubeconfig_b64}',
                env_content,
                flags=re.MULTILINE
            )
        else:
            if env_content and not env_content.endswith("\n"):
                env_content += "\n"
            env_content += f"KUBECONFIG_PRIMARY={kubeconfig_b64}\n"
            
        # Update KUBECONFIG (path to file)
        # We use a relative path from the web directory (since the app runs from there)
        kubeconfig_path = "./kubeconfig.yaml"
        if "KUBECONFIG=" in env_content:
             env_content = re.sub(
                r'^KUBECONFIG=.*$',
                f'KUBECONFIG={kubeconfig_path}',
                env_content,
                flags=re.MULTILINE
            )
        else:
            if env_content and not env_content.endswith("\n"):
                env_content += "\n"
            env_content += f"KUBECONFIG={kubeconfig_path}\n"

        # Update DATABASE_URL
        # Point to localhost:5432 which is forwarded to the VM
        db_url = "postgres://postgres:postgres@localhost:5432/catalyst"
        if "DATABASE_URL=" in env_content:
            env_content = re.sub(
                r'^DATABASE_URL=.*$',
                f'DATABASE_URL={db_url}',
                env_content,
                flags=re.MULTILINE
            )
        else:
            if env_content and not env_content.endswith("\n"):
                env_content += "\n"
            env_content += f"DATABASE_URL={db_url}\n"

        env_file.write_text(env_content)
        info("Updated KUBECONFIG, KUBECONFIG_PRIMARY, and DATABASE_URL in web/.env")
    except Exception as e:
        # Non-fatal: .env update is optional
        debug(f"Could not update .env: {e}")


def install_crds() -> None:
    """Install Custom Resource Definitions from operator directory."""
    print("  Installing CRDs...")
    operator_dir = PROJECT_ROOT / "operator"
    if not operator_dir.exists():
         print("  Warning: operator directory not found, skipping CRD installation.")
         return

    kubeconfig_path = str(KUBECONFIG_FILE.resolve())

    try:
        # We use nix develop to ensure tools (kubectl, kustomize, controller-gen) are available
        cmd = [
            "nix", "develop",
            "--command", "bash", "-c", "make install"
        ]

        env = os.environ.copy()
        env["KUBECONFIG"] = kubeconfig_path

        # Run make install in operator directory
        # We capture output to avoid cluttering unless there is an error
        run(cmd, cwd=operator_dir, env=env, capture=True)
        info("CRDs installed successfully")
    except subprocess.CalledProcessError as e:
        # If capture=True, stdout/stderr are in e.stdout/e.stderr
        msg = e.stderr if e.stderr else str(e)
        print(f"  Warning: Failed to install CRDs: {msg}")

def generate_manifest_content(deploy_apps: bool = False) -> str:
    """Generate the full Kubernetes manifest JSON with env vars injected."""
    import json

    if not BASE_MANIFEST.exists():
        error(f"Base manifest not found: {BASE_MANIFEST}")

    # Load documents from the base manifest
    with open(BASE_MANIFEST) as f:
        documents = json.load(f)

    # Get env vars from web/.env
    env_vars = get_web_env_vars()

    # Filtered documents
    final_documents = []

    # Inject env vars into web deployment
    for doc in documents:
        if doc is None:
            continue
        
        # Skip web and operator deployments unless deploy_apps is True
        if not deploy_apps and doc.get("kind") == "Deployment":
            name = doc.get("metadata", {}).get("name")
            if name in ["web", "operator"]:
                continue

        if doc.get("kind") == "Deployment" and doc.get("metadata", {}).get("name") == "web":
            spec = doc.get("spec", {}).get("template", {}).get("spec", {})

            # Inject into init containers
            for container in spec.get("initContainers", []):
                if container.get("name") == "db-migrate":
                    existing_env = container.get("env", [])
                    existing_keys = {e["name"] for e in existing_env}
                    # Only add env vars that aren't already defined in base manifest
                    filtered_env = [e for e in env_vars if e["name"] not in existing_keys]
                    container["env"] = existing_env + filtered_env

            # Inject into main container
            for container in spec.get("containers", []):
                if container.get("name") == "web":
                    existing_env = container.get("env", [])
                    existing_keys = {e["name"] for e in existing_env}
                    # Only add env vars that aren't already defined in base manifest
                    filtered_env = [e for e in env_vars if e["name"] not in existing_keys]
                    container["env"] = existing_env + filtered_env
        
        final_documents.append(doc)

    # Wrap in a List and dump to JSON
    k8s_list = {
        "apiVersion": "v1",
        "kind": "List",
        "items": final_documents
    }
    return json.dumps(k8s_list, indent=2)


def _build_vm(memory: int, cores: int, deploy_apps: bool = False) -> None:
    """Build the K3s VM using NixOS."""
    # Create config directory
    CONFIG_DIR.mkdir(parents=True, exist_ok=True)
    VM_DIR.mkdir(parents=True, exist_ok=True)

    # Get SSH key
    ssh_key = get_ssh_public_key()
    info("SSH key ready")

    # Configure forward ports
    forward_ports = [
        '{ from = "host"; host.port = 6443; guest.port = 6443; }',
        '{ from = "host"; host.port = 2666; guest.port = 22; }',
        '{ from = "host"; host.port = 5432; guest.port = 30432; }'
    ]

    # Only forward web port in --in-cluster mode (app runs in K3s)
    # In hybrid mode (default), the local dev server uses this port
    if deploy_apps:
        web_port = get_web_port()
        if web_port:
            info(f"Forwarding web port: {web_port} (in-cluster mode)")
            forward_ports.append(f'{{ from = "host"; host.port = {web_port}; guest.port = 30000; }}')
    
    forward_ports_str = "\n      ".join(forward_ports)

    # Write NixOS configuration
    config_file = VM_DIR / "configuration.nix"
    config_content = NIXOS_CONFIG_TEMPLATE.format(
        ssh_public_key=ssh_key,
        memory=memory,
        cores=cores,
        project_root=str(PROJECT_ROOT),
        forward_ports=forward_ports_str,
    )
    config_file.write_text(config_content)
    info("NixOS configuration written")

    # Build the VM
    print("  Building NixOS VM (this may take a few minutes on first run)...")
    try:
        run(
            ["nix-build", "<nixpkgs/nixos>", "-A", "vm",
             "-I", "nixpkgs=channel:nixos-24.05",
             "-I", f"nixos-config={config_file}",
             "-o", str(VM_DIR / "result")],
            cwd=VM_DIR
        )
    except subprocess.CalledProcessError:
        error("Failed to build NixOS VM")

    # Remove old disk image to ensure fresh state
    # The disk image is named after the hostname (k3s-vm.qcow2)
    for disk in VM_DIR.glob("*.qcow2"):
        disk.unlink()

def _start_vm() -> None:
    """Start the VM in background."""
    # Find the run script (name is based on hostname: run-{hostname}-vm)
    bin_dir = VM_DIR / "result" / "bin"
    vm_scripts = list(bin_dir.glob("run-*-vm"))
    if not vm_scripts:
        error("VM run script not found in result/bin/. Run 'setup' first.")
    vm_script = vm_scripts[0]

    env = os.environ.copy()
    env["QEMU_KERNEL_PARAMS"] = "console=ttyS0"
    env["QEMU_AUDIO_DRV"] = "none"
    # Unset LD_LIBRARY_PATH to prevent interference with Nix binaries (e.g. QEMU)
    env.pop("LD_LIBRARY_PATH", None)

    # Start VM process
    log_file = open(CONFIG_DIR / "vm.log", "w") # Always overwrite log on new start
    proc = subprocess.Popen(
        [str(vm_script), "-nographic"],
        cwd=VM_DIR,
        env=env,
        stdin=subprocess.DEVNULL,
        stdout=log_file,
        stderr=subprocess.STDOUT,
        start_new_session=True
    )
    PID_FILE.write_text(str(proc.pid))

def _wait_for_vm_readiness() -> None:
    """Wait for SSH and K3s to be ready in the VM."""
    print("  Waiting for VM to boot...")
    if not wait_for_ssh(180):
        error("Timeout waiting for SSH. Check VM logs.")
    info("SSH available")

    print("  Waiting for K3s to be ready...")
    if not wait_for_k3s(300):
        error("Timeout waiting for K3s. Check VM logs.")
    info("K3s ready")

def apply_manifests(deploy_apps: bool = False) -> bool:
    """Apply Kubernetes manifests using kubectl."""
    if not KUBECONFIG_FILE.exists():
        print("  Error: Kubeconfig not found. Run 'bin/k3s-vm' first.")
        return False

    manifest_content = generate_manifest_content(deploy_apps=deploy_apps)

    # Write to a temp file
    temp_manifest = CONFIG_DIR / "catalyst-manifests.json"
    temp_manifest.write_text(manifest_content)

    try:
        env = os.environ.copy()
        env["KUBECONFIG"] = str(KUBECONFIG_FILE)

        result = run(
            ["kubectl", "apply", "-f", str(temp_manifest)],
            env=env,
            capture=True
        )

        # Print applied resources
        for line in result.stdout.strip().split("\n"):
            if line:
                info(line)

        return True
    except subprocess.CalledProcessError as e:
        print(f"  Error applying manifests: {e.stderr if e.stderr else e}")
        return False


def cmd_update_manifests(args: argparse.Namespace) -> None:
    """Update Kubernetes manifests on the running VM."""
    if not is_vm_running():
        error("VM is not running. Start it with 'bin/k3s-vm'")

    print("Applying Kubernetes manifests...")
    if apply_manifests(deploy_apps=args.in_cluster):
        print("Manifests applied successfully.")
    else:
        error("Failed to apply manifests.")

def _extract_kubeconfig_and_install_crds(deploy_apps: bool = False) -> None:
    """Extract kubeconfig, install CRDs, and apply manifests."""
    print("  Extracting kubeconfig...")
    if not extract_kubeconfig():
        error("Failed to extract kubeconfig")
    info(f"Kubeconfig saved to {KUBECONFIG_FILE}")
    install_crds()

    print("  Applying Kubernetes manifests...")
    if apply_manifests(deploy_apps=deploy_apps):
        info("Manifests applied")
    else:
        print("  Warning: Failed to apply manifests. Run 'bin/k3s-vm apply' manually.")

def _ensure_vm_is_running(memory: int, cores: int, deploy_apps: bool = False) -> None:
    """Ensures the VM is built and running, and K3s is ready."""
    if is_vm_running():
        info("VM is already running.")
    else:
        # Check if VM is built
        bin_dir = VM_DIR / "result" / "bin"
        if not (bin_dir.exists() and list(bin_dir.glob("run-*-vm"))):
            print(f"Building K3s VM (NixOS)")
            print(f"  Memory: {memory}MB, Cores: {cores}")
            print()
            _build_vm(memory, cores, deploy_apps=deploy_apps)
            info("VM built successfully")
        else:
            info("VM already built.")

        info("Starting VM...")
        _start_vm()
        info(f"VM started (PID: {get_vm_pid()})")

    _wait_for_vm_readiness()
    _extract_kubeconfig_and_install_crds(deploy_apps=deploy_apps)

    print()
    print("=" * 50)
    print("K3s VM ready!")
    print()
    print(f"  SSH:        ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -p 2666 root@localhost")
    print(f"  K3s API:    https://127.0.0.1:6443")
    print(f"  Kubeconfig: {KUBECONFIG_FILE}")
    if not deploy_apps:
        print("  Mode:       Local Dev (Web/Operator pods NOT deployed)")
        print("              Run apps locally: cd web && npm run dev")
    else:
        print("  Mode:       In-Cluster (Web/Operator pods deployed)")
    print()
    print("Try: bin/kubectl get nodes")

# ============================================================================
# Commands
# ============================================================================

def cmd_stop(args: argparse.Namespace) -> None:
    """Stop the VM."""
    if not is_vm_running():
        error("VM is not running.")

    pid = get_vm_pid()
    if pid:
        print(f"Stopping VM (PID: {pid})...")
        try:
            os.kill(pid, signal.SIGTERM)
            # Wait for process to terminate
            for _ in range(30):
                try:
                    os.kill(pid, 0)
                    time.sleep(1)
                except ProcessLookupError:
                    break
            else:
                # Force kill if still running
                os.kill(pid, signal.SIGKILL)
        except ProcessLookupError:
            pass

        PID_FILE.unlink(missing_ok=True)
        print("VM stopped.")
    else:
        error("Could not find VM process.")


def cmd_status(args: argparse.Namespace) -> None:
    """Show VM status."""
    print("K3s VM Status (NixOS)")
    print()

    if is_vm_running():
        pid = get_vm_pid()
        print(f"  State: running (PID: {pid})")
        print(f"  SSH:   ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -p 2666 root@localhost")
        print(f"  API:   https://127.0.0.1:6443")

        # Check K3s status
        try:
            result = run(
                ["ssh", "-o", "StrictHostKeyChecking=no", "-o", "UserKnownHostsFile=/dev/null", "-o", "ConnectTimeout=5",
                 "-p", "2666", "root@localhost", "kubectl --kubeconfig /etc/rancher/k3s/k3s.yaml get nodes --no-headers"],
                capture=True, check=False
            )
            if result.returncode == 0:
                nodes = len([l for l in result.stdout.strip().split("\n") if l])
                print(f"  Nodes: {nodes} ready")
        except Exception:
            print("  K3s:   checking...")

        if KUBECONFIG_FILE.exists():
            print(f"\n  Kubeconfig: {KUBECONFIG_FILE}")
    else:
        bin_dir = VM_DIR / "result" / "bin"
        if bin_dir.exists() and list(bin_dir.glob("run-*-vm")):
            print("  State: stopped (VM built)")
            print("\n  Run 'bin/k3s-vm' to start")
        else:
            print("  State: not configured")
            print("\n  Run 'bin/k3s-vm' to set up and start the VM")


def find_vm_processes() -> list[int]:
    """Find all qemu processes running k3s-vm or holding required ports."""
    pids = []
    # Find by process name pattern
    try:
        result = subprocess.run(
            ["pgrep", "-f", "qemu.*-name k3s-vm"],
            capture_output=True, text=True
        )
        for line in result.stdout.strip().split("\n"):
            if line:
                pids.append(int(line))
    except (subprocess.CalledProcessError, ValueError):
        pass

    # Also find processes holding our required ports (catches orphaned VMs)
    for port in [6443, 2666]:
        try:
            result = subprocess.run(
                ["lsof", "-t", "-i", f":{port}"],
                capture_output=True, text=True
            )
            for pid in result.stdout.strip().split("\n"):
                if pid:
                    pid_int = int(pid)
                    if pid_int not in pids:
                        pids.append(pid_int)
        except (subprocess.CalledProcessError, ValueError):
            pass

    return pids


def cmd_reset(args: argparse.Namespace) -> None:
    """Reset/destroy the VM."""
    print("Resetting VM...")

    # Stop if running (check PID file first)
    if is_vm_running():
        info("Stopping VM (from PID file)...")
        pid = get_vm_pid()
        if pid:
            try:
                os.kill(pid, signal.SIGKILL)
            except ProcessLookupError:
                pass

    # Also find and kill any orphaned qemu processes for this VM
    orphan_pids = find_vm_processes()
    if orphan_pids:
        info(f"Killing orphaned VM processes: {orphan_pids}")
        for pid in orphan_pids:
            try:
                os.kill(pid, signal.SIGKILL)
            except ProcessLookupError:
                pass

    PID_FILE.unlink(missing_ok=True)

    # Remove VM directory contents
    if VM_DIR.exists():
        info("Removing VM files...")
        import shutil
        shutil.rmtree(VM_DIR, ignore_errors=True)

    # Remove kubeconfig
    if KUBECONFIG_FILE.exists():
        info("Removing kubeconfig...")
        KUBECONFIG_FILE.unlink()

    print()
    print("Reset complete. Rebuilding and starting VM...")
    _ensure_vm_is_running(DEFAULT_VM_MEMORY, DEFAULT_VM_CORES)


def cmd_ssh(args: argparse.Namespace) -> None:
    """SSH into the VM."""
    if not is_vm_running():
        error("VM is not running. Start it with 'bin/k3s-vm'")

    os.execlp("ssh", "ssh", "-o", "StrictHostKeyChecking=no", "-o", "UserKnownHostsFile=/dev/null", "-p", "2666", "root@localhost")


# ============================================================================
# Main
# ============================================================================

def main() -> None:
    parser = argparse.ArgumentParser(
        description="K3s VM Management (NixOS-native)",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  bin/k3s-vm                 Start K3s VM (Default: Hybrid mode, apps not deployed)
  bin/k3s-vm --in-cluster    Start K3s VM and deploy web/operator to cluster
  bin/k3s-vm stop            Stop VM
  bin/k3s-vm status          Check VM status
  bin/k3s-vm ssh             SSH into VM
  bin/k3s-vm reset           Destroy VM
  bin/k3s-vm apply           Update manifests without rebuilding VM
""",
    )
    parser.add_argument("--version", action="version", version="k3s-vm 2.1.0 (NixOS)")
    parser.add_argument("--debug", action="store_true", help="Enable debug output")
    parser.add_argument("--cpus", type=int, default=DEFAULT_VM_CORES, help=f"CPU cores (default: {DEFAULT_VM_CORES})")
    parser.add_argument("--memory", type=int, default=DEFAULT_VM_MEMORY, help=f"Memory in MB (default: {DEFAULT_VM_MEMORY})")
    parser.add_argument("--in-cluster", action="store_true", help="Deploy web and operator to cluster (disable for local dev)")

    subparsers = parser.add_subparsers(dest="command", help="Commands")

    # stop
    subparsers.add_parser("stop", help="Stop VM")

    # status
    subparsers.add_parser("status", help="Show VM status")

    # reset
    subparsers.add_parser("reset", help="Destroy VM")

    # ssh
    subparsers.add_parser("ssh", help="SSH into VM")

    # apply
    apply_parser = subparsers.add_parser("apply", help="Update manifests without rebuilding VM")
    apply_parser.add_argument("--in-cluster", action="store_true", help="Deploy web and operator to cluster")

    args = parser.parse_args()

    if args.debug:
        os.environ["K3S_VM_DEBUG"] = "1"
        debug("Debug mode enabled")

    if args.command is None: # No command provided, implicitly setup/start
        _ensure_vm_is_running(args.memory, args.cpus, deploy_apps=args.in_cluster)
    else:
        commands = {
            "stop": cmd_stop,
            "status": cmd_status,
            "reset": cmd_reset,
            "ssh": cmd_ssh,
            "apply": cmd_update_manifests,
        }
        commands[args.command](args)


if __name__ == "__main__":
    main()
