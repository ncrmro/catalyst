#!/usr/bin/env bash
# K3s VM Management - Main Script
# Manage local K3s development VM lifecycle

set -euo pipefail

# Get script directory and source library
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
# shellcheck source=bin/k3s-vm-lib.sh
source "$SCRIPT_DIR/k3s-vm-lib.sh"

# ============================================================================
# Help and Usage
# ============================================================================

show_help() {
    cat <<EOF
K3s VM Management

Usage: bin/k3s-vm <subcommand> [options]

Subcommands:
  setup      Create and initialize a new K3s VM
  start      Start a stopped K3s VM
  stop       Gracefully stop a running K3s VM
  status     Display VM and K3s cluster status
  reset      Destroy VM and remove all associated resources

Global Options:
  -h, --help     Show this help message
  -v, --verbose  Enable verbose output
  --debug        Enable debug logging
  --version      Show script version

Environment Variables:
  VM_NAME        Override default VM name
  DEBUG          Enable debug output (same as --debug)
  LOG_FILE       Path to log file (default: /tmp/k3s-vm.log)

Examples:
  bin/k3s-vm setup                    Create K3s VM with defaults
  bin/k3s-vm setup --cpus 4 --memory 8192
  bin/k3s-vm start                    Start the VM
  bin/k3s-vm stop                     Stop the VM gracefully
  bin/k3s-vm stop --force             Force stop the VM
  bin/k3s-vm status                   Check VM status
  bin/k3s-vm status --verbose         Detailed status
  bin/k3s-vm reset                    Remove VM (with confirmation)
  bin/k3s-vm reset --yes              Remove VM (no confirmation)

For more information, see: specs/002-local-k3s-vm/quickstart.md
EOF
}

show_version() {
    echo "k3s-vm version 1.0.0"
    echo "Local K3s Development VM Management"
}

# ============================================================================
# Placeholder Subcommand Functions (Will be implemented in later phases)
# ============================================================================

cmd_setup() {
    # Parse options
    local cpus="${VM_CPUS:-$DEFAULT_VM_CPUS}"
    local memory="${VM_MEMORY:-$DEFAULT_VM_MEMORY}"
    local disk="${VM_DISK:-$DEFAULT_VM_DISK}"

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --cpus)
                cpus="$2"
                shift 2
                ;;
            --memory)
                memory="$2"
                shift 2
                ;;
            --disk)
                disk="$2"
                shift 2
                ;;
            -h|--help)
                cat <<EOF
Usage: bin/k3s-vm setup [options]

Create and initialize a new K3s VM

Options:
  --cpus N       Number of CPU cores (default: 2)
  --memory MB    Memory in MB (default: 4096)
  --disk GB      Disk size in GB (default: 20)
  -h, --help     Show this help message

Examples:
  bin/k3s-vm setup                      # Use defaults
  bin/k3s-vm setup --cpus 4 --memory 8192 --disk 40

This command will:
1. Validate dependencies
2. Download Ubuntu cloud image if needed
3. Create VM with specified resources
4. Install K3s inside the VM
5. Extract kubeconfig to web/.kube/config

Estimated time: <5 minutes
EOF
                return 0
                ;;
            *)
                error "Unknown option: $1"
                return 1
                ;;
        esac
    done

    # Load configuration
    load_config

    # Override with command-line arguments
    VM_CPUS="$cpus"
    VM_MEMORY="$memory"
    VM_DISK="$disk"

    info "Starting K3s VM setup..."
    info "VM Name: $VM_NAME"
    info "Resources: $VM_CPUS CPUs, $VM_MEMORY MB RAM, $VM_DISK GB disk"

    # Step 1: Validate dependencies (T017)
    echo "✓ Validating dependencies..."
    if ! validate_dependencies; then
        return 1
    fi
    echo "✓ Dependencies validated"

    # Step 2: Check if VM already exists (T017)
    if vm_exists "$VM_NAME"; then
        error "VM '$VM_NAME' already exists"
        echo "Run 'bin/k3s-vm reset' to remove it first"
        return 1
    fi

    # Step 3: Ensure SSH key exists (T015)
    echo "✓ Checking SSH key..."
    if ! ensure_ssh_key; then
        return 1
    fi

    # Step 4: Create VM image (T014, T018)
    echo "✓ Creating VM disk image..."
    local vm_image
    if ! vm_image="$(create_vm_image "$VM_NAME" "$VM_DISK")"; then
        return 1
    fi

    # Step 5: Generate cloud-init ISO (T016, T018)
    echo "✓ Generating cloud-init configuration..."
    local cloud_init_iso
    if ! cloud_init_iso="$(generate_cloud_init_iso "$VM_NAME")"; then
        return 1
    fi

    # Step 6: Create VM using virt-install (T018)
    echo "✓ Creating VM (this may take a few minutes)..."
    virt-install \
        --connect qemu:///system \
        --name "$VM_NAME" \
        --ram "$VM_MEMORY" \
        --vcpus "$VM_CPUS" \
        --disk path="$vm_image",format=qcow2 \
        --disk path="$cloud_init_iso",device=cdrom \
        --os-variant ubuntu22.04 \
        --network network=default \
        --graphics none \
        --import \
        --noautoconsole || {
        error "Failed to create VM"
        return 1
    }

    # Step 7: Wait for VM to boot and be SSH accessible (T019)
    echo "✓ Waiting for VM to boot..."
    sleep 15  # Give VM time to start

    # Get VM IP
    local vm_ip
    local retries=30
    while [[ $retries -gt 0 ]]; do
        vm_ip="$(get_vm_ip "$VM_NAME")"
        if [[ -n "$vm_ip" ]]; then
            break
        fi
        sleep 5
        ((retries--))
    done

    if [[ -z "$vm_ip" ]]; then
        error "Failed to get VM IP address"
        return 1
    fi

    info "VM IP: $vm_ip"

    # Wait for SSH to be ready
    if ! wait_for_vm_ssh "$vm_ip" 300; then
        error "VM boot timeout"
        return 1
    fi

    # Step 8: Wait for K3s to be ready (T020)
    echo "✓ Waiting for K3s installation to complete..."
    sleep 30  # Give K3s time to install

    # Step 9: Extract kubeconfig (T021)
    echo "✓ Extracting kubeconfig..."
    mkdir -p "$KUBECONFIG_DIR"

    if ! ssh -o StrictHostKeyChecking=no "ubuntu@$vm_ip" "sudo cat /etc/rancher/k3s/k3s.yaml" > "$KUBECONFIG_FILE" 2>/dev/null; then
        error "Failed to extract kubeconfig from VM"
        return 1
    fi

    # Step 10: Update kubeconfig server URL (T022)
    echo "✓ Updating kubeconfig server URL..."
    sed -i "s/127.0.0.1/$vm_ip/g" "$KUBECONFIG_FILE"

    # Step 11: Verify K3s API is responding (T020)
    if ! check_k3s_api 60; then
        error "K3s API did not become ready"
        return 1
    fi

    # Step 12: Save configuration
    save_config

    # Success!
    echo ""
    echo "✓ K3s VM setup complete!"
    echo ""
    echo "VM IP: $vm_ip"
    echo "Kubeconfig: $KUBECONFIG_FILE"
    echo ""
    echo "Try: bin/kubectl get nodes"
}

cmd_start() {
    # Parse options
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -h|--help)
                cat <<EOF
Usage: bin/k3s-vm start

Start a stopped K3s VM

This command will:
1. Check if VM exists
2. Start the VM if stopped
3. Wait for VM to be accessible
4. Verify K3s API is responding

Estimated time: <30 seconds
EOF
                return 0
                ;;
            *)
                error "Unknown option: $1"
                return 1
                ;;
        esac
    done

    # Load configuration
    load_config

    info "Starting K3s VM..."

    # Check if VM exists
    if ! vm_exists "$VM_NAME"; then
        error "VM '$VM_NAME' not found"
        echo "Run 'bin/k3s-vm setup' first"
        return 1
    fi

    # Check if already running
    if is_vm_running "$VM_NAME"; then
        error "VM '$VM_NAME' is already running"
        return 1
    fi

    # Start the VM
    echo "✓ Starting VM '$VM_NAME'..."
    virsh -c qemu:///system start "$VM_NAME" || {
        error "Failed to start VM"
        return 1
    }

    # Wait for VM to get IP
    echo "✓ Waiting for VM to boot..."
    sleep 10

    local vm_ip
    local retries=30
    while [[ $retries -gt 0 ]]; do
        vm_ip="$(get_vm_ip "$VM_NAME")"
        if [[ -n "$vm_ip" ]]; then
            break
        fi
        sleep 2
        ((retries--))
    done

    if [[ -z "$vm_ip" ]]; then
        error "Failed to get VM IP address"
        return 1
    fi

    # Wait for SSH to be accessible
    if ! wait_for_vm_ssh "$vm_ip" 30; then
        error "VM did not become accessible"
        return 1
    fi

    # Wait for K3s API to respond
    if ! check_k3s_api 30; then
        error "K3s API did not become ready"
        return 1
    fi

    echo ""
    echo "✓ VM started successfully"
    echo "✓ K3s API is responding"
    echo ""
    echo "VM IP: $vm_ip"
    echo ""
    echo "Try: bin/kubectl get nodes"
}

cmd_stop() {
    # Parse options
    local force=0

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --force)
                force=1
                shift
                ;;
            -h|--help)
                cat <<EOF
Usage: bin/k3s-vm stop [--force]

Gracefully stop a running K3s VM

Options:
  --force    Force shutdown (destroy) instead of graceful shutdown

This command will:
1. Check if VM exists and is running
2. Stop the VM gracefully (or force if --force)
3. Wait for VM to stop

Estimated time: <30 seconds
EOF
                return 0
                ;;
            *)
                error "Unknown option: $1"
                return 1
                ;;
        esac
    done

    # Load configuration
    load_config

    info "Stopping K3s VM..."

    # Check if VM exists
    if ! vm_exists "$VM_NAME"; then
        error "VM '$VM_NAME' not found"
        echo "Run 'bin/k3s-vm setup' first"
        return 1
    fi

    # Check if already stopped
    if ! is_vm_running "$VM_NAME"; then
        error "VM '$VM_NAME' is already stopped"
        return 1
    fi

    # Stop the VM
    if [[ $force -eq 1 ]]; then
        echo "✓ Force stopping VM '$VM_NAME'..."
        virsh -c qemu:///system destroy "$VM_NAME" || {
            error "Failed to force stop VM"
            return 1
        }
    else
        echo "✓ Gracefully stopping VM '$VM_NAME'..."
        virsh -c qemu:///system shutdown "$VM_NAME" || {
            error "Failed to stop VM"
            return 1
        }

        # Wait for VM to stop (timeout: 60 seconds)
        local timeout=60
        local elapsed=0
        while [[ $elapsed -lt $timeout ]]; do
            if ! is_vm_running "$VM_NAME"; then
                break
            fi
            sleep 2
            ((elapsed += 2))
        done

        # Check if still running after timeout
        if is_vm_running "$VM_NAME"; then
            echo ""
            echo "WARNING: VM stop timed out after ${timeout} seconds"
            echo "Use 'bin/k3s-vm stop --force' to force shutdown"
            return 1
        fi
    fi

    echo ""
    echo "✓ VM stopped successfully"
    echo ""
    echo "Run 'bin/k3s-vm start' to restart"
}

cmd_status() {
    # Parse options
    local verbose=0

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --verbose|-v)
                verbose=1
                shift
                ;;
            -h|--help)
                cat <<EOF
Usage: bin/k3s-vm status [--verbose]

Display VM and K3s cluster status

Options:
  --verbose, -v  Show detailed VM information

This command shows:
- VM state (running, stopped, not found)
- VM resources (CPUs, memory, disk)
- K3s cluster health (if running)
- K3s version and node count (if running)
- Kubeconfig path
EOF
                return 0
                ;;
            *)
                error "Unknown option: $1"
                return 1
                ;;
        esac
    done

    # Load configuration
    load_config

    # Get VM state
    local state
    state="$(get_vm_state "$VM_NAME")"

    echo "K3s VM Status:"
    echo "  Name: $VM_NAME"
    echo "  State: $state"
    echo ""

    # VM not found
    if [[ "$state" == "undefined" ]]; then
        echo "Run 'bin/k3s-vm setup' to create the VM"
        return 0
    fi

    # Show resource information
    echo "  CPUs: $VM_CPUS"
    echo "  Memory: $VM_MEMORY MB"
    echo "  Disk: $VM_DISK GB"
    echo ""

    # If running, show cluster information
    if [[ "$state" == "running" ]]; then
        local vm_ip
        vm_ip="$(get_vm_ip "$VM_NAME")"

        if [[ -n "$vm_ip" ]]; then
            echo "  IP: $vm_ip"
            echo ""
        fi

        # Check K3s cluster health
        echo "K3s Cluster:"

        if [[ -f "$KUBECONFIG_FILE" ]]; then
            # Try to get cluster info
            export KUBECONFIG="$KUBECONFIG_FILE"

            if kubectl cluster-info &>/dev/null; then
                echo "  API: ✓ responding"

                # Get K3s version
                local k3s_version
                k3s_version="$(get_k3s_version)"
                echo "  Version: $k3s_version"

                # Get node count
                local node_count
                node_count="$(get_k3s_node_count)"
                echo "  Nodes: $node_count ready"
            else
                echo "  API: ✗ not responding"
            fi
        else
            echo "  Kubeconfig: not found"
        fi

        echo ""
        echo "Kubeconfig: $KUBECONFIG_FILE"

        # Verbose output
        if [[ $verbose -eq 1 ]]; then
            echo ""
            echo "VM Details:"

            # Get UUID
            local uuid
            uuid="$(virsh -c qemu:///system domuuid "$VM_NAME" 2>/dev/null || echo "unknown")"
            echo "  UUID: $uuid"

            # Get disk image path and usage
            local disk_image="$SCRIPT_DIR/../.k3s-vm-images/$VM_NAME.qcow2"

            if [[ -f "$disk_image" ]]; then
                echo "  Disk image: $disk_image"

                # Get disk usage
                local disk_usage
                disk_usage="$(qemu-img info "$disk_image" 2>/dev/null | grep 'virtual size' | awk '{print $3, $4}' || echo 'unknown')"
                echo "  Disk usage: $disk_usage"
            fi

            # Network information
            echo ""
            echo "Network:"
            echo "  Interface: default (NAT)"

            if [[ -n "$vm_ip" ]]; then
                echo "  IP: $vm_ip"

                # Get MAC address
                local mac
                mac="$(virsh -c qemu:///system domiflist "$VM_NAME" 2>/dev/null | grep -v '^Interface' | grep -v '^-' | awk '{print $5}' || echo 'unknown')"
                if [[ -n "$mac" && "$mac" != "unknown" ]]; then
                    echo "  MAC: $mac"
                fi
            fi
        fi
    else
        # VM is stopped
        echo "Run 'bin/k3s-vm start' to start the VM"
    fi
}

cmd_reset() {
    # Parse options
    local skip_confirm=0

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --yes|-y)
                skip_confirm=1
                shift
                ;;
            -h|--help)
                cat <<EOF
Usage: bin/k3s-vm reset [--yes]

Destroy VM and remove all associated resources

Options:
  --yes, -y  Skip confirmation prompt

This command will:
1. Stop VM if running
2. Remove VM definition from libvirt
3. Delete VM disk image
4. Remove kubeconfig file
5. Preserve .k3s-vm/config for potential recreation

WARNING: This is a destructive operation that cannot be undone.
All cluster data and deployments will be lost.
EOF
                return 0
                ;;
            *)
                error "Unknown option: $1"
                return 1
                ;;
        esac
    done

    # Load configuration
    load_config

    # Check if VM exists
    if ! vm_exists "$VM_NAME"; then
        error "VM '$VM_NAME' not found"
        echo "Nothing to reset"
        return 0
    fi

    # Confirmation prompt
    if [[ $skip_confirm -eq 0 ]]; then
        echo "WARNING: This will permanently delete the VM and all K3s cluster data"
        echo ""
        read -r -p "Are you sure you want to reset the K3s VM? (yes/no): " confirm

        if [[ "$confirm" != "yes" ]]; then
            echo "Reset cancelled"
            return 0
        fi
    fi

    info "Resetting K3s VM..."

    # Stop VM if running
    if is_vm_running "$VM_NAME"; then
        echo "✓ Stopping VM..."
        virsh -c qemu:///system destroy "$VM_NAME" 2>/dev/null || true
        sleep 2
    fi

    # Remove VM definition (without --remove-all-storage since we manage disks locally)
    echo "✓ Removing VM definition..."
    virsh -c qemu:///system undefine "$VM_NAME" || {
        error "Failed to remove VM definition"
        echo "You may need to manually remove the VM with:"
        echo "  virsh -c qemu:///system undefine $VM_NAME"
        return 1
    }

    # Remove local disk image
    local disk_image="$SCRIPT_DIR/../.k3s-vm-images/$VM_NAME.qcow2"
    if [[ -f "$disk_image" ]]; then
        echo "✓ Removing VM disk image..."
        rm -f "$disk_image"
    fi

    # Remove cloud-init ISO
    local cloud_init_iso="$SCRIPT_DIR/../.k3s-vm-images/$VM_NAME-cloud-init.iso"
    if [[ -f "$cloud_init_iso" ]]; then
        echo "✓ Removing cloud-init ISO..."
        rm -f "$cloud_init_iso"
    fi

    # Remove kubeconfig
    if [[ -f "$KUBECONFIG_FILE" ]]; then
        echo "✓ Removing kubeconfig..."
        rm -f "$KUBECONFIG_FILE"
    fi

    # Note: We preserve .k3s-vm/config for potential recreation
    # Note: We preserve .k3s-vm-images/ubuntu-*-cloudimg-*.img (base image for reuse)

    echo ""
    echo "✓ Reset complete"
    echo ""
    echo "Configuration preserved in: $CONFIG_DIR/"
    echo "Base cloud image preserved for reuse"
    echo "Run 'bin/k3s-vm setup' to create a new VM"
}

# ============================================================================
# Main Dispatcher
# ============================================================================

main() {
    # Parse global options
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -h|--help)
                show_help
                exit 0
                ;;
            --version)
                show_version
                exit 0
                ;;
            -v|--verbose)
                export VERBOSE=1
                shift
                ;;
            --debug)
                export DEBUG=1
                shift
                ;;
            setup|start|stop|status|reset)
                # Found a subcommand, execute it
                local subcommand="$1"
                shift
                "cmd_$subcommand" "$@"
                exit $?
                ;;
            *)
                error "Unknown option or subcommand: $1"
                echo ""
                show_help
                exit 1
                ;;
        esac
    done

    # No subcommand provided
    error "No subcommand specified"
    echo ""
    show_help
    exit 1
}

# Execute main function
main "$@"
