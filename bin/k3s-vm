#!/usr/bin/env python3
"""
K3s VM Management Script (NixOS-native)

Creates a local K3s development VM using NixOS configuration and QEMU.
Zero external dependencies beyond Nix.
"""

import argparse
import os
import signal
import subprocess
import sys
import time
from pathlib import Path

# ============================================================================
# Configuration
# ============================================================================

SCRIPT_DIR = Path(__file__).parent.resolve()
PROJECT_ROOT = SCRIPT_DIR.parent

# Paths
CONFIG_DIR = PROJECT_ROOT / ".k3s-vm"
VM_DIR = CONFIG_DIR / "vm"
KUBECONFIG_DIR = PROJECT_ROOT / "web" / ".kube"
KUBECONFIG_FILE = KUBECONFIG_DIR / "config"
PID_FILE = CONFIG_DIR / "vm.pid"

# VM settings
DEFAULT_VM_MEMORY = 8192
DEFAULT_VM_CORES = 4

# NixOS configuration template for K3s VM
NIXOS_CONFIG_TEMPLATE = '''
{{ config, pkgs, lib, ... }}:
{{
  # Boot configuration for VM
  boot.loader.systemd-boot.enable = true;
  boot.loader.efi.canTouchEfiVariables = true;

  # Networking
  networking.hostName = "k3s-vm";
  networking.firewall.enable = false;

  # Disable audio
  sound.enable = false;
  services.pipewire.enable = false;
  hardware.pulseaudio.enable = false;

  # Enable SSH
  services.openssh = {{
    enable = true;
    settings.PermitRootLogin = "yes";
  }};

  # K3s service
  services.k3s = {{
    enable = true;
    role = "server";
    extraFlags = toString [
      "--disable=traefik"
      "--write-kubeconfig-mode=644"
    ];
  }};

  systemd.services.k3s.postStart = ''
    until [ -f /etc/rancher/k3s/k3s.yaml ]; do sleep 1; done
    cp /etc/rancher/k3s/k3s.yaml /var/kubeconfig
    chmod 644 /var/kubeconfig
  '' ;

  # Root user with SSH key
  users.users.root = {{
    openssh.authorizedKeys.keys = [
      "{ssh_public_key}"
    ];
  }};

  # Useful packages
  environment.systemPackages = with pkgs; [
    kubectl
    k9s
    vim
    curl
    htop
  ];

  # Auto-login for console access (optional, for debugging)
  services.getty.autologinUser = "root";

  # VM-specific settings
  virtualisation.vmVariant = {{
    virtualisation.memorySize = {memory};
    virtualisation.cores = {cores};
    virtualisation.diskSize = 40960;
    virtualisation.graphics = false;

    virtualisation.sharedDirectories = {{
      code = {{
        source = "{project_root}";
        target = "/code";
      }};
    }};

    # Forward ports for K3s API and SSH
    virtualisation.forwardPorts = [
{forward_ports}
    ];
  }};

  system.stateVersion = "24.05";
}}
'''


def run(cmd: list[str], check: bool = True, capture: bool = False, **kwargs) -> subprocess.CompletedProcess:
    """Run a command and return result."""
    if capture:
        kwargs.setdefault("stdout", subprocess.PIPE)
        kwargs.setdefault("stderr", subprocess.PIPE)
        kwargs.setdefault("text", True)
    return subprocess.run(cmd, check=check, **kwargs)


def error(msg: str) -> None:
    """Print error and exit."""
    print(f"ERROR: {msg}", file=sys.stderr)
    sys.exit(1)


def info(msg: str) -> None:
    """Print info message."""
    print(f"  {msg}")


def debug(msg: str) -> None:
    """Print debug message (only if verbose)."""
    # Silent by default, can be enabled with environment variable
    if os.environ.get("K3S_VM_DEBUG"):
        print(f"  [debug] {msg}")


def get_env_var(name: str, default: int | None = None) -> int | None:
    """Get an integer env var from web/.env."""
    env_file = PROJECT_ROOT / "web" / ".env"
    if not env_file.exists():
        return default

    try:
        content = env_file.read_text()
        for line in content.splitlines():
            line = line.strip()
            if line.startswith(f"{name}="):
                return int(line.split("=", 1)[1])
    except (ValueError, IndexError):
        pass
    return default


def get_ingress_port() -> int:
    """Get INGRESS_PORT from web/.env, defaults to 8080."""
    return get_env_var("INGRESS_PORT", 8080) or 8080

def get_ssh_public_key() -> str:
    """Get or generate SSH public key."""
    ssh_key = Path.home() / ".ssh" / "id_rsa"
    ssh_pub = ssh_key.with_suffix(".pub")

    if not ssh_pub.exists():
        if not ssh_key.parent.exists():
            ssh_key.parent.mkdir(mode=0o700)
        print("Generating SSH key...")
        run(["ssh-keygen", "-t", "rsa", "-b", "4096", "-N", "", "-f", str(ssh_key)])

    return ssh_pub.read_text().strip()


def is_vm_running() -> bool:
    """Check if VM process is running."""
    if not PID_FILE.exists():
        return False

    try:
        pid = int(PID_FILE.read_text().strip())
        os.kill(pid, 0)  # Check if process exists
        return True
    except (ProcessLookupError, ValueError):
        PID_FILE.unlink(missing_ok=True)
        return False


def get_vm_pid() -> int | None:
    """Get VM process PID."""
    if not PID_FILE.exists():
        return None
    try:
        return int(PID_FILE.read_text().strip())
    except ValueError:
        return None


def wait_for_ssh(timeout: int = 120) -> bool:
    """Wait for SSH to become available."""
    start = time.time()
    while time.time() - start < timeout:
        try:
            result = run(
                ["ssh", "-o", "StrictHostKeyChecking=no", "-o", "UserKnownHostsFile=/dev/null", "-o", "ConnectTimeout=5",
                 "-o", "BatchMode=yes", "-p", "2666", "root@localhost", "true"],
                capture=True, check=False
            )
            if result.returncode == 0:
                return True
            debug(f"SSH check failed (code {result.returncode}): {result.stderr.strip()}")
        except Exception as e:
            debug(f"SSH check error: {e}")
            pass
        time.sleep(2)
    return False


def wait_for_k3s(timeout: int = 300) -> bool:
    """Wait for K3s API to become available."""
    start = time.time()
    while time.time() - start < timeout:
        try:
            result = run(
                ["ssh", "-o", "StrictHostKeyChecking=no", "-o", "UserKnownHostsFile=/dev/null", "-p", "2666",
                 "root@localhost", "kubectl --kubeconfig /etc/rancher/k3s/k3s.yaml get nodes"],
                capture=True, check=False
            )
            if result.returncode == 0 and "Ready" in result.stdout:
                return True
            
            debug(f"K3s check failed (code {result.returncode})")
            if result.stdout: debug(f"stdout: {result.stdout.strip()}")
            if result.stderr: debug(f"stderr: {result.stderr.strip()}")
        except Exception as e:
            debug(f"K3s check error: {e}")
            pass
        time.sleep(3)
    return False


def extract_kubeconfig() -> bool:
    """Extract kubeconfig from VM and update .env for integration tests."""
    try:
        result = run(
            ["ssh", "-o", "StrictHostKeyChecking=no", "-o", "UserKnownHostsFile=/dev/null", "-p", "2666",
             "root@localhost", "cat /etc/rancher/k3s/k3s.yaml"],
            capture=True
        )

        # Replace localhost with 127.0.0.1:6443 (forwarded port)
        kubeconfig = result.stdout.replace("127.0.0.1:6443", "127.0.0.1:6443")
        kubeconfig = kubeconfig.replace("https://127.0.0.1", "https://127.0.0.1")

        KUBECONFIG_DIR.mkdir(parents=True, exist_ok=True)
        KUBECONFIG_FILE.write_text(kubeconfig)

        # Create a symlink in the web root for easier access/CLI usage
        # web/kubeconfig.yaml -> .kube/config
        web_root = PROJECT_ROOT / "web"
        symlink_path = web_root / "kubeconfig.yaml"
        target_path = Path(".kube/config") # Relative to web/
        
        # Atomic replacement of symlink
        if symlink_path.exists() or symlink_path.is_symlink():
            symlink_path.unlink()
        symlink_path.symlink_to(target_path)
        info("Created symlink web/kubeconfig.yaml -> .kube/config")

        # Also update .env with base64-encoded JSON kubeconfig for integration tests
        update_env_kubeconfig(kubeconfig)

        return True
    except subprocess.CalledProcessError:
        return False


def update_env_kubeconfig(kubeconfig_yaml: str) -> None:
    """Update KUBECONFIG_PRIMARY and KUBECONFIG in web/.env."""
    import base64
    import json
    import re

    env_file = PROJECT_ROOT / "web" / ".env"
    # Ensure web/.env exists
    if not env_file.exists():
        env_file.write_text("")

    # Convert YAML to JSON using node (available in web directory)
    try:
        result = run(
            ["node", "-e", f"""
const yaml = require('yaml');
const kubeconfig = yaml.parse({json.dumps(kubeconfig_yaml)});
console.log(JSON.stringify(kubeconfig));
"""],
            capture=True,
            cwd=PROJECT_ROOT / "web"
        )
        kubeconfig_json = result.stdout.strip()
        kubeconfig_b64 = base64.b64encode(kubeconfig_json.encode()).decode()

        env_content = env_file.read_text()
        
        # Update KUBECONFIG_PRIMARY
        if "KUBECONFIG_PRIMARY=" in env_content:
            env_content = re.sub(
                r'^KUBECONFIG_PRIMARY=.*$',
                f'KUBECONFIG_PRIMARY={kubeconfig_b64}',
                env_content,
                flags=re.MULTILINE
            )
        else:
            if env_content and not env_content.endswith("\n"):
                env_content += "\n"
            env_content += f"KUBECONFIG_PRIMARY={kubeconfig_b64}\n"
            
        # Update KUBECONFIG (path to file)
        # We use a relative path from the web directory (since the app runs from there)
        kubeconfig_path = "./kubeconfig.yaml"
        if "KUBECONFIG=" in env_content:
             env_content = re.sub(
                r'^KUBECONFIG=.*$',
                f'KUBECONFIG={kubeconfig_path}',
                env_content,
                flags=re.MULTILINE
            )
        else:
            if env_content and not env_content.endswith("\n"):
                env_content += "\n"
            env_content += f"KUBECONFIG={kubeconfig_path}\n"

        # Update DATABASE_URL
        # Point to localhost:5432 which is forwarded to the VM
        db_url = "postgres://postgres:postgres@localhost:5432/catalyst"
        if "DATABASE_URL=" in env_content:
            env_content = re.sub(
                r'^DATABASE_URL=.*$',
                f'DATABASE_URL={db_url}',
                env_content,
                flags=re.MULTILINE
            )
        else:
            if env_content and not env_content.endswith("\n"):
                env_content += "\n"
            env_content += f"DATABASE_URL={db_url}\n"

        env_file.write_text(env_content)
        info("Updated KUBECONFIG, KUBECONFIG_PRIMARY, and DATABASE_URL in web/.env")
    except Exception as e:
        # Non-fatal: .env update is optional
        debug(f"Could not update .env: {e}")


def install_crds() -> None:
    """Install Custom Resource Definitions from operator directory."""
    print("  Installing CRDs...")
    operator_dir = PROJECT_ROOT / "operator"
    if not operator_dir.exists():
         print("  Warning: operator directory not found, skipping CRD installation.")
         return

    kubeconfig_path = str(KUBECONFIG_FILE.resolve())

    try:
        # Attempt direct installation first if kubectl is available
        # config/crd is a kustomization directory
        env = os.environ.copy()
        env["KUBECONFIG"] = kubeconfig_path
        
        try:
            debug("Attempting direct CRD installation via kubectl apply -k")
            run(["kubectl", "apply", "-k", "config/crd"], cwd=operator_dir, env=env, capture=True)
            info("CRDs installed successfully (via kubectl)")
            return
        except (subprocess.CalledProcessError, FileNotFoundError):
            # Fall back to nix develop + make install
            debug("Direct kubectl apply failed or not available, falling back to make install")

        # We use nix develop to ensure tools (kubectl, kustomize, controller-gen) are available
        cmd = [
            "nix", "develop",
            "--command", "bash", "-c", "make install"
        ]

        # Run make install in operator directory
        # We capture output to avoid cluttering unless there is an error
        run(cmd, cwd=operator_dir, env=env, capture=True)
        info("CRDs installed successfully (via make)")
    except subprocess.CalledProcessError as e:
        # If capture=True, stdout/stderr are in e.stdout/e.stderr
        error_output = e.stderr if e.stderr else e.stdout
        msg = error_output if error_output else str(e)
        print(f"  Warning: Failed to install CRDs:\n{msg}")


def _build_vm(memory: int, cores: int) -> None:
    """Build the K3s VM using NixOS."""
    # Create config directory
    CONFIG_DIR.mkdir(parents=True, exist_ok=True)
    VM_DIR.mkdir(parents=True, exist_ok=True)

    # Get SSH key
    ssh_key = get_ssh_public_key()
    info("SSH key ready")

    # Configure forward ports
    ingress_port = get_ingress_port()
    forward_ports = [
        '{ from = "host"; host.port = 6443; guest.port = 6443; }',
        '{ from = "host"; host.port = 2666; guest.port = 22; }',
        f'{{ from = "host"; host.port = {ingress_port}; guest.port = 30080; }}'  # Ingress HTTP
    ]

    # Only forward 5432 if it's not already in use on the host
    # This allows a local PostgreSQL (e.g. from nix devshell) to take precedence
    import socket
    def is_port_in_use(port):
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
            return s.connect_ex(('localhost', port)) == 0

    if not is_port_in_use(5432):
        forward_ports.append('{ from = "host"; host.port = 5432; guest.port = 30432; }')
        info("Forwarding host port 5432 to VM PostgreSQL (NodePort 30432)")
    else:
        info("Host port 5432 is already in use, skipping VM PostgreSQL forwarding")

    forward_ports_str = "\n      ".join(forward_ports)

    # Write NixOS configuration
    config_file = VM_DIR / "configuration.nix"
    config_content = NIXOS_CONFIG_TEMPLATE.format(
        ssh_public_key=ssh_key,
        memory=memory,
        cores=cores,
        project_root=str(PROJECT_ROOT),
        forward_ports=forward_ports_str,
    )
    config_file.write_text(config_content)
    info("NixOS configuration written")

    # Build the VM
    print("  Building NixOS VM (this may take a few minutes on first run)...")
    try:
        run(
            ["nix-build", "<nixpkgs/nixos>", "-A", "vm",
             "-I", "nixpkgs=channel:nixos-24.05",
             "-I", f"nixos-config={config_file}",
             "-o", str(VM_DIR / "result")],
            cwd=VM_DIR
        )
    except subprocess.CalledProcessError:
        error("Failed to build NixOS VM")

    # Remove old disk image to ensure fresh state
    # The disk image is named after the hostname (k3s-vm.qcow2)
    for disk in VM_DIR.glob("*.qcow2"):
        disk.unlink()

def _start_vm() -> None:
    """Start the VM in background."""
    # Find the run script (name is based on hostname: run-{hostname}-vm)
    bin_dir = VM_DIR / "result" / "bin"
    vm_scripts = list(bin_dir.glob("run-*-vm"))
    if not vm_scripts:
        error("VM run script not found in result/bin/. Run 'setup' first.")
    vm_script = vm_scripts[0]

    env = os.environ.copy()
    env["QEMU_KERNEL_PARAMS"] = "console=ttyS0"
    env["QEMU_AUDIO_DRV"] = "none"
    # Unset LD_LIBRARY_PATH to prevent interference with Nix binaries (e.g. QEMU)
    env.pop("LD_LIBRARY_PATH", None)

    # Start VM process
    log_file = open(CONFIG_DIR / "vm.log", "w") # Always overwrite log on new start
    proc = subprocess.Popen(
        [str(vm_script), "-nographic"],
        cwd=VM_DIR,
        env=env,
        stdin=subprocess.DEVNULL,
        stdout=log_file,
        stderr=subprocess.STDOUT,
        start_new_session=True
    )
    PID_FILE.write_text(str(proc.pid))

def _wait_for_vm_readiness() -> None:
    """Wait for SSH and K3s to be ready in the VM."""
    print("  Waiting for VM to boot...")
    if not wait_for_ssh(180):
        error("Timeout waiting for SSH. Check VM logs.")
    info("SSH available")

    print("  Waiting for K3s to be ready...")
    if not wait_for_k3s(300):
        error("Timeout waiting for K3s. Check VM logs.")
    info("K3s ready")

def _extract_kubeconfig_and_install_crds() -> None:
    """Extract kubeconfig and install CRDs."""
    print("  Extracting kubeconfig...")
    if not extract_kubeconfig():
        error("Failed to extract kubeconfig")
    info(f"Kubeconfig saved to {KUBECONFIG_FILE}")
    install_crds()

def _ensure_vm_is_running(memory: int, cores: int) -> None:
    """Ensures the VM is built and running, and K3s is ready."""
    if is_vm_running():
        info("VM is already running.")
    else:
        # Check if VM is built
        bin_dir = VM_DIR / "result" / "bin"
        if not (bin_dir.exists() and list(bin_dir.glob("run-*-vm"))):
            print(f"Building K3s VM (NixOS)")
            print(f"  Memory: {memory}MB, Cores: {cores}")
            print()
            _build_vm(memory, cores)
            info("VM built successfully")
        else:
            info("VM already built.")

        info("Starting VM...")
        _start_vm()
        info(f"VM started (PID: {get_vm_pid()})")

    _wait_for_vm_readiness()
    _extract_kubeconfig_and_install_crds()

    print()
    print("=" * 50)
    print("K3s VM ready!")
    print()
    print(f"  SSH:        ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -p 2666 root@localhost")
    print(f"  K3s API:    https://127.0.0.1:6443")
    print(f"  Kubeconfig: {KUBECONFIG_FILE}")
    print("  Mode:       Bare cluster (CRDs installed)")
    print("              Deploy via Helm or run apps locally: cd web && npm run dev")
    print()
    print("Try: bin/kubectl get nodes")

# ============================================================================
# Commands
# ============================================================================

def cmd_stop(args: argparse.Namespace) -> None:
    """Stop the VM."""
    if not is_vm_running():
        error("VM is not running.")

    pid = get_vm_pid()
    if pid:
        print(f"Stopping VM (PID: {pid})...")
        try:
            os.kill(pid, signal.SIGTERM)
            # Wait for process to terminate
            for _ in range(30):
                try:
                    os.kill(pid, 0)
                    time.sleep(1)
                except ProcessLookupError:
                    break
            else:
                # Force kill if still running
                os.kill(pid, signal.SIGKILL)
        except ProcessLookupError:
            pass

        PID_FILE.unlink(missing_ok=True)
        print("VM stopped.")
    else:
        error("Could not find VM process.")


def cmd_status(args: argparse.Namespace) -> None:
    """Show VM status."""
    print("K3s VM Status (NixOS)")
    print()

    if is_vm_running():
        pid = get_vm_pid()
        print(f"  State: running (PID: {pid})")
        print(f"  SSH:   ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -p 2666 root@localhost")
        print(f"  API:   https://127.0.0.1:6443")

        # Check K3s status
        try:
            result = run(
                ["ssh", "-o", "StrictHostKeyChecking=no", "-o", "UserKnownHostsFile=/dev/null", "-o", "ConnectTimeout=5",
                 "-p", "2666", "root@localhost", "kubectl --kubeconfig /etc/rancher/k3s/k3s.yaml get nodes --no-headers"],
                capture=True, check=False
            )
            if result.returncode == 0:
                nodes = len([l for l in result.stdout.strip().split("\n") if l])
                print(f"  Nodes: {nodes} ready")
        except Exception:
            print("  K3s:   checking...")

        if KUBECONFIG_FILE.exists():
            print(f"\n  Kubeconfig: {KUBECONFIG_FILE}")
    else:
        bin_dir = VM_DIR / "result" / "bin"
        if bin_dir.exists() and list(bin_dir.glob("run-*-vm")):
            print("  State: stopped (VM built)")
            print("\n  Run 'bin/k3s-vm' to start")
        else:
            print("  State: not configured")
            print("\n  Run 'bin/k3s-vm' to set up and start the VM")


def find_vm_processes() -> list[int]:
    """Find all qemu processes running k3s-vm or holding required ports."""
    pids = []
    # Find by process name pattern
    try:
        result = subprocess.run(
            ["pgrep", "-f", "qemu.*-name k3s-vm"],
            capture_output=True, text=True
        )
        for line in result.stdout.strip().split("\n"):
            if line:
                pids.append(int(line))
    except (subprocess.CalledProcessError, ValueError):
        pass

    # Also find processes holding our required ports (catches orphaned VMs)
    for port in [6443, 2666]:
        try:
            result = subprocess.run(
                ["lsof", "-t", "-i", f":{port}"],
                capture_output=True, text=True
            )
            for pid in result.stdout.strip().split("\n"):
                if pid:
                    pid_int = int(pid)
                    if pid_int not in pids:
                        pids.append(pid_int)
        except (subprocess.CalledProcessError, ValueError):
            pass

    return pids


def cmd_reset(args: argparse.Namespace) -> None:
    """Reset/destroy the VM."""
    print("Resetting VM...")

    # Stop if running (check PID file first)
    if is_vm_running():
        info("Stopping VM (from PID file)...")
        pid = get_vm_pid()
        if pid:
            try:
                os.kill(pid, signal.SIGKILL)
            except ProcessLookupError:
                pass

    # Also find and kill any orphaned qemu processes for this VM
    orphan_pids = find_vm_processes()
    if orphan_pids:
        info(f"Killing orphaned VM processes: {orphan_pids}")
        for pid in orphan_pids:
            try:
                os.kill(pid, signal.SIGKILL)
            except ProcessLookupError:
                pass

    PID_FILE.unlink(missing_ok=True)

    # Remove VM directory contents
    if VM_DIR.exists():
        info("Removing VM files...")
        import shutil
        shutil.rmtree(VM_DIR, ignore_errors=True)

    # Remove kubeconfig
    if KUBECONFIG_FILE.exists():
        info("Removing kubeconfig...")
        KUBECONFIG_FILE.unlink()

    print()
    print("Reset complete. Rebuilding and starting VM...")
    _ensure_vm_is_running(DEFAULT_VM_MEMORY, DEFAULT_VM_CORES)


def cmd_ssh(args: argparse.Namespace) -> None:
    """SSH into the VM."""
    if not is_vm_running():
        error("VM is not running. Start it with 'bin/k3s-vm'")

    os.execlp("ssh", "ssh", "-o", "StrictHostKeyChecking=no", "-o", "UserKnownHostsFile=/dev/null", "-p", "2666", "root@localhost")


# ============================================================================
# Main
# ============================================================================

def main() -> None:
    parser = argparse.ArgumentParser(
        description="K3s VM Management (NixOS-native)",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  bin/k3s-vm                 Start bare K3s VM (cluster + CRDs only)
  bin/k3s-vm stop            Stop VM
  bin/k3s-vm status          Check VM status
  bin/k3s-vm ssh             SSH into VM
  bin/k3s-vm reset           Destroy VM
""",
    )
    parser.add_argument("--version", action="version", version="k3s-vm 3.0.0 (NixOS)")
    parser.add_argument("--debug", action="store_true", help="Enable debug output")
    parser.add_argument("--cpus", type=int, default=DEFAULT_VM_CORES, help=f"CPU cores (default: {DEFAULT_VM_CORES})")
    parser.add_argument("--memory", type=int, default=DEFAULT_VM_MEMORY, help=f"Memory in MB (default: {DEFAULT_VM_MEMORY})")

    subparsers = parser.add_subparsers(dest="command", help="Commands")

    # stop
    subparsers.add_parser("stop", help="Stop VM")

    # status
    subparsers.add_parser("status", help="Show VM status")

    # reset
    subparsers.add_parser("reset", help="Destroy VM")

    # ssh
    subparsers.add_parser("ssh", help="SSH into VM")

    args = parser.parse_args()

    if args.debug:
        os.environ["K3S_VM_DEBUG"] = "1"
        debug("Debug mode enabled")

    if args.command is None: # No command provided, implicitly setup/start
        _ensure_vm_is_running(args.memory, args.cpus)
    else:
        commands = {
            "stop": cmd_stop,
            "status": cmd_status,
            "reset": cmd_reset,
            "ssh": cmd_ssh,
        }
        commands[args.command](args)


if __name__ == "__main__":
    main()
