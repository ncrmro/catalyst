#!/usr/bin/env python3

import os
import subprocess
import shutil
import sys

def get_project_root():
    """Get the project root directory (parent of bin/)."""
    script_dir = os.path.dirname(os.path.abspath(__file__))
    return os.path.dirname(script_dir)

def rename_zellij_tab(tab_name):
    """Rename the current Zellij tab if Zellij is available."""
    if shutil.which("zellij"):
        try:
            subprocess.run(["zellij", "action", "rename-tab", tab_name], check=False)
        except Exception:
            pass

def get_spec_status(spec_name, project_root):
    """Get the recent status/commits for a spec."""
    specs_status_script = os.path.join(project_root, "bin", "spec-status")
    if os.path.exists(specs_status_script):
        try:
            result = subprocess.run(
                [specs_status_script, spec_name],
                capture_output=True,
                text=True,
                check=False
            )
            if result.returncode == 0:
                return result.stdout
        except Exception as e:
            print(f"Warning: Could not get spec status: {e}", file=sys.stderr)
    return ""

def main():
    """Run Gemini with worktree support."""
    project_root = get_project_root()

    # Process arguments to handle --worktree flag
    args = sys.argv[1:]
    processed_args = []
    worktree_path = None
    initial_prompt = None

    i = 0
    while i < len(args):
        if args[i] == "--worktree":
            # Get the branch/spec name
            if i + 1 >= len(args):
                print("Error: --worktree requires a branch/spec name argument", file=sys.stderr)
                sys.exit(1)

            branch_input = args[i + 1]

            # Rename zellij tab
            tab_suffix = branch_input
            if branch_input.startswith("specs/"):
                tab_suffix = branch_input[len("specs/"):]
            elif branch_input.startswith("spec/"):
                tab_suffix = branch_input[len("spec/"):]
            rename_zellij_tab(f"gemini-{tab_suffix}")
            
            # Resolve worktree path using the same logic as bin/worktree
            if branch_input.startswith("specs/") or branch_input.startswith("spec/"):
                if branch_input.startswith("specs/"):
                    sub_path = branch_input[len("specs/"):]
                else:
                    sub_path = branch_input[len("spec/"):]
                worktree_rel_path = os.path.join("specs", sub_path)
            else:
                worktree_rel_path = branch_input.replace('/', '-')

            # Construct the full worktree path
            worktree_path = os.path.join(project_root, "worktree", worktree_rel_path)

            # Check if worktree exists, create it if not
            if not os.path.exists(worktree_path):
                print(f"Worktree not found at {worktree_path}", file=sys.stderr)
                print(f"Creating worktree for '{branch_input}'...", file=sys.stderr)

                # Call bin/worktree to create the worktree
                worktree_script = os.path.join(project_root, "bin", "worktree")
                try:
                    subprocess.run([worktree_script, branch_input], check=True)
                except subprocess.CalledProcessError as e:
                    print(f"Error creating worktree: {e}", file=sys.stderr)
                    sys.exit(1)
                except FileNotFoundError:
                    print(f"Error: bin/worktree script not found at {worktree_script}", file=sys.stderr)
                    sys.exit(1)

            # Check if we are working on a spec
            spec_instructions = f"Refocus on the spec '{branch_input}' which should now be available inside this worktree. "
            
            # Add context files using @ syntax
            for filename in ["spec.md", "plan.md", "tasks.md"]:
                file_path = os.path.join(worktree_path, filename)
                if os.path.exists(file_path):
                    relative_path = os.path.relpath(file_path, project_root)
                    spec_instructions += f" @{relative_path}"

            # Get spec status
            spec_status = get_spec_status(branch_input, project_root)
            if spec_status:
                spec_instructions += f"\n\nHere is the recent activity/status for this spec:\n\n{spec_status}\n"

            # Construct the prompt for the LLM
            initial_prompt = (
                f"I am working in the worktree located at: {worktree_path}. "
                f"Please acknowledge this by confirming you will change your working directory to this path "
                f"and only create, read, update, or delete files within this directory. "
                f"{spec_instructions}"
                f"Note: The development server has NOT been started automatically. If you need to run the application, "
                f"please run 'make up' within the worktree directory."
            )

            # Skip the worktree flag and its argument
            i += 2
        else:
            processed_args.append(args[i])
            i += 1

    # If no worktree was specified, check if the current directory is a spec
    if not initial_prompt:
        cwd = os.getcwd()
        spec_path = os.path.join(cwd, "spec.md")
        if os.path.exists(spec_path):
            spec_name = os.path.basename(cwd)
            rename_zellij_tab(f"gemini-{spec_name}")
            spec_instructions = f"Refocus on the spec '{spec_name}' which is available in the current directory. "
            
            # Add context files using @ syntax
            for filename in ["spec.md", "plan.md", "tasks.md"]:
                file_path = os.path.join(cwd, filename)
                if os.path.exists(file_path):
                    relative_path = os.path.relpath(file_path, project_root)
                    spec_instructions += f" @{relative_path}"
                
            # Get spec status
            spec_status = get_spec_status(spec_name, project_root)
            if spec_status:
                spec_instructions += f"\n\nHere is the recent activity/status for this spec:\n\n{spec_status}\n"

            initial_prompt = spec_instructions

    # Construct the final command
    cmd = ["gemini"]

    if worktree_path:
        cmd.extend(["--include-directories", worktree_path])
        
    if initial_prompt:
        # Use --prompt-interactive to pass the initial instruction
        cmd.extend(["--prompt-interactive", initial_prompt])
    
    # Add remaining arguments
    cmd.extend(processed_args)

    # Execute the command
    try:
        # Debug output to see what's being executed (optional, but helpful)
        # print(f"Executing: {' '.join(cmd)}", file=sys.stderr)
        os.execvp("gemini", cmd)
    except OSError as e:
        print(f"Error executing gemini: {e}", file=sys.stderr)
        sys.exit(1)

if __name__ == "__main__":
    main()
