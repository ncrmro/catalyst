#!/usr/bin/env python3

import json
import os
import subprocess
import sys

def get_project_root():
    """Get the project root directory (parent of bin/)."""
    script_dir = os.path.dirname(os.path.abspath(__file__))
    return os.path.dirname(script_dir)

def create_mcp_config(workspace_path):
    """Create the MCP server configuration."""
    return {
        "mcpServers": {
            "typescript-lsp": {
                "command": "mcp-language-server",
                "args": [
                    "--workspace",
                    workspace_path,
                    "--lsp",
                    "typescript-language-server",
                    "--",
                    "--stdio"
                ]
            },
            "playwright": {
                "type": "stdio",
                "command": "npx",
                "env": {
                    "PLAYWRIGHT_BROWSERS_PATH": "",
                    "PLAYWRIGHT_SKIP_VALIDATE_HOST_REQUIREMENTS": "true"
                },
                "args": [
                    "@playwright/mcp@latest",
                    "--browser=chromium",
                    "--executable-path=/nix/store/ciwl3hnki3yvx36vjsagx2yhrcy8jb1k-playwright-browsers/chromium-1181/chrome-linux/chrome"
                ]
            },
            "docker": {
                "type": "stdio",
                "command": "uvx",
                "args": [
                    "docker-mcp"
                ],
                "env": {}
            }
        }
    }

def main():
    """Run Claude with MCP server configuration."""
    project_root = get_project_root()

    # Process arguments to handle --worktree flag
    args = sys.argv[1:]
    processed_args = []
    workspace_path = project_root  # Default to project root
    i = 0

    while i < len(args):
        if args[i] == "--worktree":
            # Get the branch/spec name
            if i + 1 >= len(args):
                print("Error: --worktree requires a branch name argument", file=sys.stderr)
                sys.exit(1)

            branch_input = args[i + 1]

            # Resolve worktree path using the same logic as bin/worktree
            if branch_input.startswith("specs/") or branch_input.startswith("spec/"):
                if branch_input.startswith("specs/"):
                    sub_path = branch_input[len("specs/"):]
                else:
                    sub_path = branch_input[len("spec/"):]
                worktree_rel_path = os.path.join("specs", sub_path)
            else:
                worktree_rel_path = branch_input.replace('/', '-')

            # Construct the full worktree path
            worktree_path = os.path.join(project_root, "worktree", worktree_rel_path)

            # Check if worktree exists, create it if not
            if not os.path.exists(worktree_path):
                print(f"Worktree not found at {worktree_path}", file=sys.stderr)
                print(f"Creating worktree for '{branch_input}'...", file=sys.stderr)

                # Call bin/worktree to create the worktree
                worktree_script = os.path.join(project_root, "bin", "worktree")
                try:
                    subprocess.run([worktree_script, branch_input], check=True)
                except subprocess.CalledProcessError as e:
                    print(f"Error creating worktree: {e}", file=sys.stderr)
                    sys.exit(1)
                except FileNotFoundError:
                    print(f"Error: bin/worktree script not found at {worktree_script}", file=sys.stderr)
                    sys.exit(1)

            # Update workspace path for TypeScript LSP
            workspace_path = worktree_path

            # Add the --add-dir flag
            processed_args.extend(["--add-dir", worktree_path])

            # Add the --append-system-prompt flag
            system_prompt = (
                f"You are handling work in worktree located at {worktree_path}, "
                f"only read or edit files in that directory, all commands should be run in that directory"
            )
            processed_args.extend(["--append-system-prompt", system_prompt])

            # Skip the worktree branch name argument
            i += 2
        else:
            # Pass through other arguments
            processed_args.append(args[i])
            i += 1

    # Create MCP config with the appropriate workspace path
    mcp_config = create_mcp_config(workspace_path)
    mcp_config_json = json.dumps(mcp_config)

    # Build the command: claude --mcp-config <json> <processed args>
    cmd = ["claude", "--mcp-config", mcp_config_json] + processed_args

    # Execute the command, replacing the current process
    try:
        os.execvp("claude", cmd)
    except OSError as e:
        print(f"Error executing claude: {e}", file=sys.stderr)
        sys.exit(1)

if __name__ == "__main__":
    main()
