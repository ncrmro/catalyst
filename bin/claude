#!/usr/bin/env python3

import json
import os
import subprocess
import shutil
import sys

def get_project_root():
    """Get the project root directory (parent of bin/)."""
    script_dir = os.path.dirname(os.path.abspath(__file__))
    return os.path.dirname(script_dir)

def rename_zellij_tab(tab_name):
    """Rename the current Zellij tab if Zellij is available."""
    if shutil.which("zellij"):
        try:
            subprocess.run(["zellij", "action", "rename-tab", tab_name], check=False)
        except Exception:
            pass

def get_spec_status(spec_name, project_root):
    """Get the recent status/commits for a spec."""
    specs_status_script = os.path.join(project_root, "bin", "spec-status")
    if os.path.exists(specs_status_script):
        try:
            result = subprocess.run(
                [specs_status_script, spec_name],
                capture_output=True,
                text=True,
                check=False
            )
            if result.returncode == 0:
                return result.stdout
        except Exception as e:
            print(f"Warning: Could not get spec status: {e}", file=sys.stderr)
    return ""

def create_mcp_config(workspace_path):
    """Create the MCP server configuration."""
    return {
        "mcpServers": {
            "typescript-lsp": {
                "command": "mcp-language-server",
                "args": [
                    "--workspace",
                    workspace_path,
                    "--lsp",
                    "typescript-language-server",
                    "--",
                    "--stdio"
                ]
            },
            "playwright": {
                "type": "stdio",
                "command": "npx",
                "env": {
                    "PLAYWRIGHT_BROWSERS_PATH": "",
                    "PLAYWRIGHT_SKIP_VALIDATE_HOST_REQUIREMENTS": "true"
                },
                "args": [
                    "@playwright/mcp@latest",
                    "--browser=chromium",
                    "--executable-path=/nix/store/ciwl3hnki3yvx36vjsagx2yhrcy8jb1k-playwright-browsers/chromium-1181/chrome-linux/chrome"
                ]
            },
            "docker": {
                "type": "stdio",
                "command": "uvx",
                "args": [
                    "docker-mcp"
                ],
                "env": {}
            }
        }
    }

def main():
    """Run Claude with MCP server configuration."""
    project_root = get_project_root()

    # Process arguments to handle --worktree flag
    args = sys.argv[1:]
    processed_args = []
    workspace_path = project_root  # Default to project root
    i = 0

    while i < len(args):
        if args[i] == "--worktree":
            # Get the branch/spec name
            if i + 1 >= len(args):
                print("Error: --worktree requires a branch name argument", file=sys.stderr)
                sys.exit(1)

            branch_input = args[i + 1]

            # Rename zellij tab
            tab_suffix = branch_input
            if branch_input.startswith("specs/"):
                tab_suffix = branch_input[len("specs/"):]
            elif branch_input.startswith("spec/"):
                tab_suffix = branch_input[len("spec/"):]
            rename_zellij_tab(f"claude-{tab_suffix}")

            # Resolve worktree path using the same logic as bin/worktree
            if branch_input.startswith("specs/") or branch_input.startswith("spec/"):
                if branch_input.startswith("specs/"):
                    sub_path = branch_input[len("specs/"):]
                else:
                    sub_path = branch_input[len("spec/"):]
                worktree_rel_path = os.path.join("specs", sub_path)
            else:
                worktree_rel_path = branch_input.replace('/', '-')

            # Construct the full worktree path
            worktree_path = os.path.join(project_root, "worktree", worktree_rel_path)

            # Check if worktree exists, create it if not
            if not os.path.exists(worktree_path):
                print(f"Worktree not found at {worktree_path}", file=sys.stderr)
                print(f"Creating worktree for '{branch_input}'...", file=sys.stderr)

                # Call bin/worktree to create the worktree
                worktree_script = os.path.join(project_root, "bin", "worktree")
                try:
                    subprocess.run([worktree_script, branch_input], check=True)
                except subprocess.CalledProcessError as e:
                    print(f"Error creating worktree: {e}", file=sys.stderr)
                    sys.exit(1)
                except FileNotFoundError:
                    print(f"Error: bin/worktree script not found at {worktree_script}", file=sys.stderr)
                    sys.exit(1)

            # Update workspace path for TypeScript LSP
            workspace_path = worktree_path

            # Add the --add-dir flag
            processed_args.extend(["--add-dir", worktree_path])

            # Check if we are working on a spec
            spec_path = os.path.join(worktree_path, "spec.md")
            spec_instructions = ""
            if os.path.exists(spec_path):
                spec_instructions = f"Refocus on the spec '{branch_input}' which should now be available inside this worktree. "
                try:
                    with open(spec_path, "r") as f:
                        spec_content = f.read()
                    spec_instructions += f"\n\nHere is the spec content for context:\n\n{spec_content}\n"
                except Exception as e:
                    print(f"Warning: Could not read spec file at {spec_path}: {e}", file=sys.stderr)

            # Get spec status
            spec_status = get_spec_status(branch_input, project_root)
            if spec_status:
                spec_instructions += f"\n\nHere is the recent activity/status for this spec:\n\n{spec_status}\n"

            # Add the --append-system-prompt flag
            system_prompt = (
                f"You are handling work in worktree located at {worktree_path}, "
                f"only read or edit files in that directory, all commands should be run in that directory. "
                f"{spec_instructions}"
                f"Note: The development server has NOT been started automatically. If you need to run the application, "
                f"please run 'make up' within the worktree directory."
            )
            processed_args.extend(["--append-system-prompt", system_prompt])

            # Skip the worktree branch name argument
            i += 2
        else:
            # Pass through other arguments
            processed_args.append(args[i])
            i += 1

    # If no worktree was specified, check if the current directory is a spec
    # Use workspace_path == project_root as an indicator that no worktree was set
    if workspace_path == project_root:
        cwd = os.getcwd()
        spec_path = os.path.join(cwd, "spec.md")
        if os.path.exists(spec_path):
            spec_name = os.path.basename(cwd)
            rename_zellij_tab(f"claude-{spec_name}")
            spec_instructions = f"Refocus on the spec '{spec_name}' which is available in the current directory. "
            try:
                with open(spec_path, "r") as f:
                    spec_content = f.read()
                spec_instructions += f"\n\nHere is the spec content for context:\n\n{spec_content}\n"
                
                # Get spec status
                spec_status = get_spec_status(spec_name, project_root)
                if spec_status:
                    spec_instructions += f"\n\nHere is the recent activity/status for this spec:\n\n{spec_status}\n"

                processed_args.extend(["--append-system-prompt", spec_instructions])
            except Exception as e:
                print(f"Warning: Could not read spec file at {spec_path}: {e}", file=sys.stderr)

    # Create MCP config with the appropriate workspace path
    mcp_config = create_mcp_config(workspace_path)
    mcp_config_json = json.dumps(mcp_config)

    # Build the command: claude --mcp-config <json> <processed args>
    cmd = ["claude", "--mcp-config", mcp_config_json] + processed_args

    # Execute the command, replacing the current process
    try:
        os.execvp("claude", cmd)
    except OSError as e:
        print(f"Error executing claude: {e}", file=sys.stderr)
        sys.exit(1)

if __name__ == "__main__":
    main()
