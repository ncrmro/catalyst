#!/usr/bin/env python3

import json
import os
import subprocess
import shutil
import sys

def get_project_root():
    """Get the project root directory (parent of bin/)."""
    script_dir = os.path.dirname(os.path.abspath(__file__))
    return os.path.dirname(script_dir)

def rename_zellij_tab(tab_name):
    """Rename the current Zellij tab if Zellij is available."""
    if shutil.which("zellij"):
        try:
            subprocess.run(["zellij", "action", "rename-tab", tab_name], check=False)
        except Exception:
            pass

def get_spec_status(spec_name, project_root):
    """Get the recent status/commits for a spec."""
    specs_status_script = os.path.join(project_root, "bin", "spec-status")
    if os.path.exists(specs_status_script):
        try:
            result = subprocess.run(
                [specs_status_script, spec_name],
                capture_output=True,
                text=True,
                check=False
            )
            if result.returncode == 0:
                return result.stdout
        except Exception as e:
            print(f"Warning: Could not get spec status: {e}", file=sys.stderr)
    return ""

def create_mcp_config(workspace_path):
    """Create the MCP server configuration."""
    return {
        "mcpServers": {
            "typescript-lsp": {
                "command": "mcp-language-server",
                "args": [
                    "--workspace",
                    workspace_path,
                    "--lsp",
                    "typescript-language-server",
                    "--",
                    "--stdio"
                ]
            },
            "playwright": {
                "type": "stdio",
                "command": "npx",
                "env": {
                    "PLAYWRIGHT_BROWSERS_PATH": "",
                    "PLAYWRIGHT_SKIP_VALIDATE_HOST_REQUIREMENTS": "true"
                },
                "args": [
                    "@playwright/mcp@latest",
                    "--browser=chromium",
                    "--executable-path=/nix/store/ciwl3hnki3yvx36vjsagx2yhrcy8jb1k-playwright-browsers/chromium-1181/chrome-linux/chrome"
                ]
            },
            "docker": {
                "type": "stdio",
                "command": "uvx",
                "args": [
                    "docker-mcp"
                ],
                "env": {}
            }
        }
    }

def main():
    """Run Claude with MCP server configuration."""
    project_root = get_project_root()

    # Process arguments to handle --worktree flag
    args = sys.argv[1:]
    processed_args = []
    workspace_path = project_root  # Default to project root
    i = 0

    while i < len(args):
        if args[i] == "--worktree":
            # Get the branch/spec name
            if i + 1 >= len(args):
                print("Error: --worktree requires a branch name argument", file=sys.stderr)
                sys.exit(1)

            branch_input = args[i + 1]

            # Rename zellij tab
            tab_suffix = branch_input
            if branch_input.startswith("specs/"):
                tab_suffix = branch_input[len("specs/"):]
            elif branch_input.startswith("spec/"):
                tab_suffix = branch_input[len("spec/"):]
            rename_zellij_tab(f"claude-{tab_suffix}")

            # Resolve worktree path using the same logic as bin/worktree
            if branch_input.startswith("specs/") or branch_input.startswith("spec/"):
                if branch_input.startswith("specs/"):
                    sub_path = branch_input[len("specs/"):]
                else:
                    sub_path = branch_input[len("spec/"):]
                worktree_rel_path = os.path.join("specs", sub_path)
            else:
                worktree_rel_path = branch_input.replace('/', '-')

            # Construct the full worktree path
            worktree_path = os.path.join(project_root, "worktree", worktree_rel_path)

            # Check if worktree exists, create it if not
            if not os.path.exists(worktree_path):
                print(f"Worktree not found at {worktree_path}", file=sys.stderr)
                print(f"Creating worktree for '{branch_input}'...", file=sys.stderr)

                # Call bin/worktree to create the worktree
                worktree_script = os.path.join(project_root, "bin", "worktree")
                try:
                    subprocess.run([worktree_script, branch_input], check=True)
                except subprocess.CalledProcessError as e:
                    print(f"Error creating worktree: {e}", file=sys.stderr)
                    sys.exit(1)
                except FileNotFoundError:
                    print(f"Error: bin/worktree script not found at {worktree_script}", file=sys.stderr)
                    sys.exit(1)

            # Update workspace path for TypeScript LSP
            workspace_path = worktree_path

            # Add the --add-dir flag
            processed_args.extend(["--add-dir", worktree_path])

            # Check if we are working on a spec
            # Resolve the relative spec directory within the worktree
            if branch_input.startswith("specs/") or branch_input.startswith("spec/"):
                if branch_input.startswith("specs/"):
                    spec_name = branch_input[len("specs/"):]
                else:
                    spec_name = branch_input[len("spec/"):]
                spec_rel_dir = os.path.join("specs", spec_name)
            else:
                spec_rel_dir = os.path.join("specs", branch_input)
            
            spec_instructions = ""
            spec_files_found = []
            for filename in ["spec.md", "plan.md", "tasks.md"]:
                file_path = os.path.join(worktree_path, spec_rel_dir, filename)
                if os.path.exists(file_path):
                    # We want the path relative to the worktree root for the agent
                    agent_rel_path = os.path.join(spec_rel_dir, filename)
                    spec_files_found.append(f" @{agent_rel_path}")
            
            if spec_files_found:
                # Use the resolved spec_name for the message if available
                display_name = branch_input
                if branch_input.startswith("specs/") or branch_input.startswith("spec/"):
                    if branch_input.startswith("specs/"):
                        display_name = branch_input[len("specs/"):]
                    else:
                        display_name = branch_input[len("spec/"):]
                
                spec_instructions = f"Refocus on the spec '{display_name}' which should now be available inside this worktree. "
                spec_instructions += "".join(spec_files_found)

                # Get spec status
                spec_status = get_spec_status(display_name, project_root)
                if spec_status:
                    spec_instructions += f"\n\nHere is the recent activity/status for this spec:\n\n{spec_status}\n"
            else:
                spec_instructions = ""

            # Add the --append-system-prompt flag
            system_prompt = (
                f"You are handling work in worktree located at {worktree_path}. "
                f"Your working directory has been set to this path. "
                f"Only read or edit files in this directory, and all commands should be run here. "
                f"{spec_instructions}"
                f"Note: The development server has NOT been started automatically. If you need to run the application, "
                f"please run 'make up' within the worktree directory. "
                f"Acknowledge this setup and wait for further instructions."
            )
            processed_args.extend(["--append-system-prompt", system_prompt])

            # Change to the worktree directory
            os.chdir(worktree_path)

            # Skip the worktree branch name argument
            i += 2
        else:
            # Pass through other arguments
            processed_args.append(args[i])
            i += 1

    # If no worktree was specified, check if the current directory is a spec
    # Use workspace_path == project_root as an indicator that no worktree was set
    if workspace_path == project_root:
        cwd = os.getcwd()
        spec_path = os.path.join(cwd, "spec.md")
        if os.path.exists(spec_path):
            spec_name = os.path.basename(cwd)
            rename_zellij_tab(f"claude-{spec_name}")
            spec_instructions = f"Refocus on the spec '{spec_name}' which is available in the current directory. "
            
            # Add context files using @ syntax
            # If we are already inside a spec directory (e.g. specs/007-agents)
            # then spec.md is just ./spec.md
            for filename in ["spec.md", "plan.md", "tasks.md"]:
                if os.path.exists(os.path.join(cwd, filename)):
                    spec_instructions += f" @{filename}"
                
            # Get spec status
            spec_status = get_spec_status(spec_name, project_root)
            if spec_status:
                spec_instructions += f"\n\nHere is the recent activity/status for this spec:\n\n{spec_status}\n"

            processed_args.extend(["--append-system-prompt", spec_instructions])

    # Create MCP config with the appropriate workspace path
    mcp_config = create_mcp_config(workspace_path)
    mcp_config_json = json.dumps(mcp_config)

    # Build the command: claude --mcp-config <json> <processed args>
    cmd = ["claude", "--mcp-config", mcp_config_json] + processed_args

    # Execute the command, replacing the current process
    try:
        os.execvp("claude", cmd)
    except OSError as e:
        print(f"Error executing claude: {e}", file=sys.stderr)
        sys.exit(1)

if __name__ == "__main__":
    main()
