#!/bin/bash
# Catalyst North Star Local Integration Test
#
# This script provides a reliable way to run the North Star integration tests locally,
# mirroring the GitHub Actions CI environment. It uses bin/k3s-vm (QEMU/NixOS) to provide
# a clean, isolated Kubernetes environment, bypassing common issues with rootless Docker and Kind.
#
# Specification:
# 1. Prerequisites Check: Verifies Docker, Make, and bin/k3s-vm are available.
# 2. Environment Isolation: Resets and starts a fresh K3s VM to ensure test consistency.
# 3. In-Cluster Dependencies: Deploys a local Docker Registry and Cert Manager (with fake ClusterIssuer).
# 4. Image Pipeline: Builds the Operator image locally and imports it directly into the VM's containerd.
# 5. Deployment: Deploys the Operator to the VM cluster using the 'test' image.
# 6. Test Data Setup: Configures required secrets and generates manifests with valid Git SHAs.
# 7. Multi-Variant Validation: Executes bin/validate-envs for:
#    - Helm Source Resolution (Standard CI variant)
#    - Zero-Config Next.js (Auto-Dockerfile, LibSQL)
#    - Zero-Config Rails (Auto-Dockerfile, PostgreSQL)
# 8. Git Cleanup: Restores the local git state (kustomization.yaml) and removes temporary 
#    manifests on exit. The K3s VM is left running for inspection.

set -e

# Colors
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
RED='\033[0;31m'
NC='\033[0m' # No Color

# Configuration
REGISTRY_NAME="registry"
REGISTRY_PORT="5000"
SSH_CMD="ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -p 2666 root@localhost"

# Parse Arguments
RESET_VM=false
for arg in "$@"; do
    if [ "$arg" == "--reset" ]; then
        RESET_VM=true
    fi
done

echo -e "${YELLOW}=== North Star Local Integration Test (K3s VM) ===${NC}"
echo "Note: Using k3s-vm instead of Kind due to potential rootless Docker compatibility issues."

# Cleanup Function (Local Files Only)
cleanup() {
    echo -e "${YELLOW}--> Cleaning up local git state...${NC}"
    
    # Remove generated test manifests
    rm -f operator/examples/gen-ci-valid.yaml
    rm -f operator/examples/gen-zero-config.nextjs-libsql.yaml
    rm -f operator/examples/gen-zero-config.rails-postgres.yaml
    
    # Restore operator kustomization.yaml if modified
    # (The 'make deploy' command modifies this file in-place)
    if git diff --name-only | grep -q "operator/config/manager/kustomization.yaml"; then
        echo "Restoring operator/config/manager/kustomization.yaml..."
        git restore operator/config/manager/kustomization.yaml
    fi
    echo -e "${GREEN}Cleanup complete. K3s VM is still running for inspection.${NC}"
}
# Set trap to ensure cleanup happens on exit
trap cleanup EXIT

# 1. Prerequisites Check
echo -e "${GREEN}--> Checking prerequisites...${NC}"
command -v docker >/dev/null 2>&1 || { echo "Error: docker is required for building images"; exit 1; }
command -v make >/dev/null 2>&1 || { echo "Error: make is required"; exit 1; }
# Check if k3s-vm script exists
if [ ! -f "bin/k3s-vm" ]; then
    echo "Error: bin/k3s-vm not found"
    exit 1
fi

# 2. Start K3s VM
if [ "$RESET_VM" = true ]; then
    echo -e "${GREEN}--> Resetting and Starting K3s VM...${NC}"
    ./bin/k3s-vm reset
else
    echo -e "${GREEN}--> Ensuring K3s VM is running...${NC}"
    ./bin/k3s-vm
fi

# Set KUBECONFIG for subsequent commands
export KUBECONFIG=$(pwd)/web/.kube/config
echo "KUBECONFIG set to $KUBECONFIG"

# Wait a moment for connection to stabilize if needed, though k3s-vm waits for readiness
sleep 2

# 3. Clean Cluster State (if not resetting VM)
if [ "$RESET_VM" = false ]; then
    echo -e "${YELLOW}--> Cleaning up previous test resources...${NC}"
    
    # TODO: Implement Project Finalizer (Task T022) to handle this dependency automatically.
    # Currently, if we delete a Project, the Environment controller might get stuck or fail
    # because it loses its parent reference. We must delete Environments FIRST.
    
    # Delete Environments first
    echo "Deleting environments..."
    kubectl delete environments --all --ignore-not-found --wait=true --timeout=30s || true
    
    # Force remove finalizers if environments are still stuck
    if kubectl get environments -o name | grep -q "environment"; then
        echo -e "${YELLOW}Environments stuck. Force removing finalizers...${NC}"
        kubectl get environments -o name | xargs -r -I {} kubectl patch {} -p '{"metadata":{"finalizers":[]}}' --type=merge
        kubectl delete environments --all --ignore-not-found --wait=true
    fi
    
    # Then Delete Projects
    echo "Deleting projects..."
    kubectl delete projects --all --ignore-not-found --wait=true
    
    # Delete generated resources
    kubectl delete jobs,deployments,services,pods --all --ignore-not-found --wait=true
    
    # Delete test secrets (excluding registry/git secrets which we want to keep if possible, 
    # but the script recreates them anyway, so safe to delete or let script handle idempotency)
    # The script checks for existence before creating secrets, so we can leave them or delete them.
    # Let's delete to be safe and ensure fresh credentials if they changed.
    kubectl delete secret github-pat-secret --ignore-not-found
    
    echo "Cluster state cleaned."
fi

# 4. Install Registry
if ! kubectl get pod $REGISTRY_NAME -n default >/dev/null 2>&1; then
    echo -e "${GREEN}--> Installing In-Cluster Registry...${NC}"
    kubectl run $REGISTRY_NAME --image=registry:2 --port=$REGISTRY_PORT
    kubectl expose pod $REGISTRY_NAME --name=$REGISTRY_NAME --port=$REGISTRY_PORT --type=ClusterIP
    kubectl wait --for=condition=ready pod/$REGISTRY_NAME --timeout=120s
else
    echo "Registry already installed."
fi

# 4. Install Cert Manager
echo -e "${GREEN}--> Installing Cert Manager...${NC}"
kubectl apply -f https://github.com/cert-manager/cert-manager/releases/download/v1.14.4/cert-manager.yaml
kubectl wait --for=condition=Available deployment/cert-manager-webhook -n cert-manager --timeout=120s

# Create fake ClusterIssuer
cat <<EOF | kubectl apply -f -
apiVersion: cert-manager.io/v1
kind: ClusterIssuer
metadata:
  name: letsencrypt-prod
spec:
  selfSigned: {}
EOF

# 5. Build and Import Operator Image
echo -e "${GREEN}--> Building Operator Image...${NC}"
(cd operator && make docker-build IMG=catalyst-operator:test)

echo -e "${GREEN}--> Importing Operator Image into K3s VM...${NC}"
# Pipe docker save output directly to k3s ctr import in the VM
docker save catalyst-operator:test | $SSH_CMD "k3s ctr images import -"

# 6. Deploy Operator
echo -e "${GREEN}--> Deploying Operator...${NC}"
(cd operator && make deploy IMG=catalyst-operator:test)

# Force restart to ensure new image is used (if operator was already running)
kubectl rollout restart deployment/catalyst-controller-manager -n catalyst-system
kubectl rollout status deployment/catalyst-controller-manager -n catalyst-system --timeout=60s

# 7. Prepare Test Data
echo -e "${GREEN}--> Preparing Test Data...${NC}"
# Create dummy git secret if not exists
if ! kubectl get secret github-pat-secret -n default >/dev/null 2>&1; then
    kubectl create secret generic github-pat-secret \
        --from-literal=token=dummy-token \
        --namespace=default
fi

# Get a valid SHA from main for testing
echo "Fetching origin/main to get valid SHA..."
git fetch origin main
SHA=$(git rev-parse origin/main)
echo "Using commit SHA: $SHA"

# Create Valid CI Test Manifest
cat <<EOF > operator/examples/gen-ci-valid.yaml
apiVersion: catalyst.catalyst.dev/v1alpha1
kind: Project
metadata:
  name: ci-project
  namespace: default
spec:
  sources:
    - name: catalyst
      repositoryUrl: https://github.com/ncrmro/catalyst
      branch: main

  templates:
    ci-test:
      type: helm
      path: charts/example
      sourceRef: catalyst

---
apiVersion: catalyst.catalyst.dev/v1alpha1
kind: Environment
metadata:
  name: ci-env
  namespace: default
spec:
  projectRef:
    name: ci-project
  type: ci-test
  sources:
    - name: catalyst
      branch: main
      commitSha: "$SHA"
EOF

# Create Zero-Config Next.js Manifest
cat <<EOF > operator/examples/gen-zero-config.nextjs-libsql.yaml
apiVersion: catalyst.catalyst.dev/v1alpha1
kind: Project
metadata:
  name: nextjs-starter
  namespace: default
spec:
  sources:
    - name: web
      repositoryUrl: https://github.com/ncrmro/catalyst
      branch: main

  templates:
    development:
      type: helm
      path: charts/catalyst-nextjs
      builds:
        - name: web
          sourceRef: web
          path: /web

---
apiVersion: catalyst.catalyst.dev/v1alpha1
kind: Environment
metadata:
  name: nextjs-pr-123
  namespace: default
spec:
  projectRef:
    name: nextjs-starter
  type: development
  sources:
    - name: web
      branch: main
      commitSha: "$SHA"
EOF

# Create Zero-Config Rails Manifest
cat <<EOF > operator/examples/gen-zero-config.rails-postgres.yaml
apiVersion: catalyst.catalyst.dev/v1alpha1
kind: Project
metadata:
  name: rails-blog
  namespace: default
spec:
  sources:
    - name: api
      repositoryUrl: https://github.com/ncrmro/catalyst
      branch: main

  templates:
    development:
      type: helm
      path: charts/catalyst-rails
      builds:
        - name: api
          sourceRef: api
          path: /boilerplate/rails

---
apiVersion: catalyst.catalyst.dev/v1alpha1
kind: Environment
metadata:
  name: rails-pr-456
  namespace: default
spec:
  projectRef:
    name: rails-blog
  type: development
  sources:
    - name: api
      branch: main
      commitSha: "$SHA"
EOF

# 8. Run Validation
echo -e "${GREEN}--> Running Validation...${NC}"
# 8.1 CI Valid Variant (Helm Source Resolution)
echo "Testing CI Valid Variant (Helm Source Resolution)..."
kubectl apply -f operator/examples/gen-ci-valid.yaml

# 8.2 Zero-Config Variants (Kaniko/Auto-Dockerfile)
echo "Testing Zero-Config Variants (Next.js/LibSQL and Rails/PostgreSQL)..."
# We use the examples from operator/examples/
kubectl apply -f operator/examples/gen-zero-config.nextjs-libsql.yaml
kubectl apply -f operator/examples/gen-zero-config.rails-postgres.yaml

# Run validation script for all variants
# nextjs-pr-123 and rails-pr-456 are defined in the zero-config examples
CI=true ./bin/validate-envs ci-env nextjs-pr-123 rails-pr-456

echo -e "${GREEN}=== Test Complete ===${NC}"