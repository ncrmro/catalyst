# tasks:implement_task
#
# Write code to complete the selected task
#
# Generated by DeepWork - do not edit manually

description = "Write code to complete the selected task"

prompt = """
# tasks:implement_task

**Step 4/8** in **tasks** workflow

> Execute implementation tasks from specs, PRs, or branches to completion

## Prerequisites (Verify First)

Before proceeding, confirm these steps are complete:
- `/tasks:select_task`

## Instructions

**Goal**: Write code to complete the selected task

# Implement Task

## Objective

Write the code changes necessary to complete the selected task, following project conventions and best practices.

## Task

Implement the selected task by writing or modifying code, ensuring the changes are complete, tested where appropriate, and follow the project's established patterns.

### Process

1. **Read task context**
   - Load `tasks/selected_task.json` from the previous step
   - Understand the task requirements fully
   - Review related files identified in context

2. **Analyze the codebase**
   - Read CLAUDE.md for project conventions
   - Examine existing patterns in related code
   - Identify the right files to modify or create
   - Understand the architecture and layers

3. **Plan the implementation**
   - Break down the task into specific code changes
   - List files to create or modify
   - Identify any dependencies to add
   - Note any tests that need to be written

4. **Implement the changes**

   Follow these principles:
   - **Match existing patterns** - Use the same style as surrounding code
   - **Keep changes minimal** - Only change what's necessary for the task
   - **Handle errors appropriately** - Add error handling where needed
   - **Add comments sparingly** - Only where logic isn't self-evident
   - **No placeholders** - Complete all implementation, no TODOs left behind

5. **Write tests if applicable**
   - Add unit tests for new functions
   - Update existing tests if behavior changed
   - Ensure test coverage for edge cases

6. **Self-review the changes**
   - Check for security issues (injection, XSS, etc.)
   - Verify no debugging code left behind
   - Ensure code compiles/lints cleanly
   - Confirm task requirements are fully met

7. **Document the implementation**
   - Summarize what was changed and why
   - Note any architectural decisions made
   - List files modified

## Output Format

### tasks/implementation_summary.md

A markdown summary of the implementation work completed.

**Structure**:

```markdown
# Implementation Summary

## Task

**ID**: task-1a
**Title**: Add login form

## Changes Made

### Files Created

- `src/components/auth/LoginForm.tsx` - Login form component with email/password fields

### Files Modified

- `src/app/login/page.tsx` - Added LoginForm component to login page
- `src/lib/auth.ts` - Added validateCredentials function

### Dependencies Added

- None

## Implementation Details

### LoginForm Component

Created a new React component that:

- Renders email and password input fields
- Validates input before submission
- Handles loading and error states
- Calls the auth API on submit

### Key Decisions

- Used React Hook Form for form state management (matches existing patterns)
- Added client-side validation for immediate feedback
- Followed existing error handling patterns from SignupForm

## Tests Added

- `__tests__/components/LoginForm.test.tsx` - Unit tests for form validation and submission

## Verification

- [x] Code follows project conventions
- [x] No placeholder TODOs remaining
- [x] Error handling in place
- [x] Tests pass locally
```

## Quality Criteria

- All code changes for the task are complete
- No placeholder or TODO comments left behind
- Code follows project conventions (check CLAUDE.md)
- Any new functions have appropriate error handling
- Changes are minimal and focused on the task
- Implementation summary accurately describes changes
- When all criteria are met, include `<promise>âœ“ Quality Criteria Met</promise>` in your response

## Context

This is the core implementation step where actual code is written. The goal is to complete the task fully in one pass, with high-quality code that follows project patterns. The implementation summary helps track what changed and provides context for code review.


### Job Context

A comprehensive workflow for driving implementation tasks to completion. Takes tasks
from multiple sources (tasks.md specs, PR descriptions, or branch context) and
executes them one at a time through the full development cycle.

The workflow:
1. Detects or accepts explicit task source (branch, PR, or spec file)
2. Parses and displays available tasks
3. Selects a task (smart selection or user-specified)
4. Implements the code changes
5. Validates locally (tests + typecheck)
6. Commits changes and marks task complete
7. Monitors CI for success
8. Debugs failures by fetching logs and E2E screenshots

Key features:
- Supports tasks.md, PR descriptions, and GitHub issues as task sources
- One task at a time execution for careful review
- Full CI validation with smart log extraction
- Auto-downloads E2E failure screenshots for debugging
- In-place task tracking (updates source directly)

Target users: Developers working with spec-driven or PR-based task workflows.


## Required Inputs


**Files from Previous Steps** - Read these first:
- `tasks/selected_task.json` (from `select_task`)

## Work Branch

Use branch format: `deepwork/tasks-[instance]-YYYYMMDD`

- If on a matching work branch: continue using it
- If on main/master: create new branch with `git checkout -b deepwork/tasks-[instance]-$(date +%Y%m%d)`

## Outputs

**Required outputs**:
- `tasks/implementation_summary.md`

## On Completion

1. Verify outputs are created
2. Inform user: "Step 4/8 complete, outputs: tasks/implementation_summary.md"
3. **Tell user next command**: `/tasks:validate_task`

---

**Reference files**: `.deepwork/jobs/tasks/job.yml`, `.deepwork/jobs/tasks/steps/implement_task.md`
"""