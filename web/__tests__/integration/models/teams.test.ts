/**
 * @vitest-environment node
 */

import { describe, it, expect, beforeAll, afterAll, beforeEach } from "vitest";
import { db, teamsMemberships, teams, users } from "@/db";
import { eq } from "drizzle-orm";
import { getTeamsForUser } from "@/models/teams";
import { userFactory, teamFactory } from "../../factories";

/**
 * Integration tests for teams model
 *
 * Tests all model functions with real database operations
 */
describe("Teams Model Integration", () => {
  let testUserId: string;
  let testOwnerId: string;
  const createdTeamIds: string[] = [];
  const createdUserIds: string[] = [];

  beforeAll(async () => {
    // Create test user for team membership
    const testUser = await userFactory.create({
      name: "Teams Test User",
    });
    testUserId = testUser.id;
    createdUserIds.push(testUserId);

    // Create test owner for teams
    const testOwner = await userFactory.create({
      name: "Team Owner",
    });
    testOwnerId = testOwner.id;
    createdUserIds.push(testOwnerId);
  });

  afterAll(async () => {
    // Clean up teams (cascades will handle memberships)
    if (createdTeamIds.length > 0) {
      for (const teamId of createdTeamIds) {
        await db.delete(teams).where(eq(teams.id, teamId));
      }
    }

    // Clean up users
    if (createdUserIds.length > 0) {
      for (const userId of createdUserIds) {
        await db.delete(users).where(eq(users.id, userId));
      }
    }
  });

  beforeEach(() => {
    // Reset created teams list for tracking
    createdTeamIds.length = 0;
  });

  describe("getTeamsForUser", () => {
    it("should return teams where user is a member", async () => {
      // Create a team with owner
      const team = await teamFactory.create({
        ownerId: testOwnerId,
        name: "Test Team",
      });
      createdTeamIds.push(team.id);

      // Add test user as member
      await db.insert(teamsMemberships).values({
        teamId: team.id,
        userId: testUserId,
        role: "member",
      });

      const result = await getTeamsForUser(testUserId);

      expect(result.length).toBeGreaterThanOrEqual(1);
      const userTeam = result.find((t) => t.id === team.id);
      expect(userTeam).toBeDefined();
      expect(userTeam?.name).toBe("Test Team");
      expect(userTeam?.role).toBe("member");
    });

    it("should include owner information", async () => {
      const team = await teamFactory.create({
        ownerId: testOwnerId,
        name: "Team with Owner Info",
      });
      createdTeamIds.push(team.id);

      await db.insert(teamsMemberships).values({
        teamId: team.id,
        userId: testUserId,
        role: "member",
      });

      const result = await getTeamsForUser(testUserId);

      const userTeam = result.find((t) => t.id === team.id);
      expect(userTeam).toBeDefined();
      expect(userTeam?.owner).toBeDefined();
      expect(userTeam?.owner.name).toBe("Team Owner");
      expect(userTeam?.owner.email).toBeDefined(); // Email is auto-generated by faker
      expect(userTeam?.ownerId).toBe(testOwnerId);
    });

    it("should return correct role for team member", async () => {
      const team = await teamFactory.create({
        ownerId: testOwnerId,
        name: "Role Test Team",
      });
      createdTeamIds.push(team.id);

      await db.insert(teamsMemberships).values({
        teamId: team.id,
        userId: testUserId,
        role: "admin",
      });

      const result = await getTeamsForUser(testUserId);

      const userTeam = result.find((t) => t.id === team.id);
      expect(userTeam?.role).toBe("admin");
    });

    it("should return multiple teams for user", async () => {
      const [team1, team2, team3] = await Promise.all([
        teamFactory.create({ ownerId: testOwnerId, name: "Team 1" }),
        teamFactory.create({ ownerId: testOwnerId, name: "Team 2" }),
        teamFactory.create({ ownerId: testOwnerId, name: "Team 3" }),
      ]);
      createdTeamIds.push(team1.id, team2.id, team3.id);

      // Add user to all teams
      await Promise.all([
        db.insert(teamsMemberships).values({
          teamId: team1.id,
          userId: testUserId,
          role: "member",
        }),
        db.insert(teamsMemberships).values({
          teamId: team2.id,
          userId: testUserId,
          role: "admin",
        }),
        db.insert(teamsMemberships).values({
          teamId: team3.id,
          userId: testUserId,
          role: "member",
        }),
      ]);

      const result = await getTeamsForUser(testUserId);

      expect(result.length).toBeGreaterThanOrEqual(3);
      expect(result.some((t) => t.name === "Team 1")).toBe(true);
      expect(result.some((t) => t.name === "Team 2")).toBe(true);
      expect(result.some((t) => t.name === "Team 3")).toBe(true);
    });

    it("should return empty array when user is not member of any team", async () => {
      // Create a new user who is not a member of any team
      const newUser = await userFactory.create({
        name: "New User",
      });
      createdUserIds.push(newUser.id);

      const result = await getTeamsForUser(newUser.id);

      expect(result).toEqual([]);
    });

    it("should only return teams where user is a member", async () => {
      const [userTeam, otherTeam] = await Promise.all([
        teamFactory.create({ ownerId: testOwnerId, name: "User Team" }),
        teamFactory.create({ ownerId: testOwnerId, name: "Other Team" }),
      ]);
      createdTeamIds.push(userTeam.id, otherTeam.id);

      // Add user only to userTeam
      await db.insert(teamsMemberships).values({
        teamId: userTeam.id,
        userId: testUserId,
        role: "member",
      });

      // Don't add user to otherTeam

      const result = await getTeamsForUser(testUserId);

      expect(result.some((t) => t.id === userTeam.id)).toBe(true);
      expect(result.some((t) => t.id === otherTeam.id)).toBe(false);
    });

    it("should include all team properties", async () => {
      const team = await teamFactory.create({
        ownerId: testOwnerId,
        name: "Complete Team",
        description: "This is a test team",
      });
      createdTeamIds.push(team.id);

      await db.insert(teamsMemberships).values({
        teamId: team.id,
        userId: testUserId,
        role: "member",
      });

      const result = await getTeamsForUser(testUserId);

      const userTeam = result.find((t) => t.id === team.id);
      expect(userTeam).toBeDefined();
      expect(userTeam).toHaveProperty("id");
      expect(userTeam).toHaveProperty("name");
      expect(userTeam).toHaveProperty("description");
      expect(userTeam).toHaveProperty("ownerId");
      expect(userTeam).toHaveProperty("createdAt");
      expect(userTeam).toHaveProperty("updatedAt");
      expect(userTeam).toHaveProperty("role");
      expect(userTeam).toHaveProperty("owner");

      expect(userTeam?.name).toBe("Complete Team");
      expect(userTeam?.description).toBe("This is a test team");
      expect(userTeam?.createdAt).toBeInstanceOf(Date);
      expect(userTeam?.updatedAt).toBeInstanceOf(Date);
    });

    it("should handle user who is owner and member of their own team", async () => {
      // Create a team owned by testUserId
      const ownTeam = await teamFactory.create({
        ownerId: testUserId,
        name: "Own Team",
      });
      createdTeamIds.push(ownTeam.id);

      // Add testUserId as member of their own team
      await db.insert(teamsMemberships).values({
        teamId: ownTeam.id,
        userId: testUserId,
        role: "owner",
      });

      const result = await getTeamsForUser(testUserId);

      const ownUserTeam = result.find((t) => t.id === ownTeam.id);
      expect(ownUserTeam).toBeDefined();
      expect(ownUserTeam?.ownerId).toBe(testUserId);
      expect(ownUserTeam?.role).toBe("owner");
    });
  });
});
