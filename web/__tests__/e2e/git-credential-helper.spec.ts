import { test, expect } from "./fixtures/k8s-fixture";
import type {
  BatchV1Api,
  CoreV1Api,
  CustomObjectsApi,
} from "@kubernetes/client-node";

/**
 * E2E Test: Git Credential Helper via Operator
 *
 * This test validates the FULL operator flow:
 * 1. Project CR → defines sources and build templates
 * 2. Environment CR → triggers operator reconciliation
 * 3. Operator creates ConfigMap with embedded git scripts
 * 4. Operator creates Build Job with git credential helper
 * 5. Git clone succeeds via /api/git-token/pat endpoint
 *
 * Unlike the previous test, this validates the actual operator behavior:
 * - ConfigMap creation (ensureGitScriptsConfigMap)
 * - Build Job spec (desiredBuildJob)
 * - Git credential helper authentication
 */

// Test configuration
const TEST_TEAM = "e2e-test";
const TEST_PROJECT = "e2e-git-cred-test";
const TEST_ENVIRONMENT = "e2e-git-cred-env";

// Target namespace generated by operator: team-project-environment
const TARGET_NAMESPACE = `${TEST_TEAM}-${TEST_PROJECT}-${TEST_ENVIRONMENT}`;

// API constants for custom resources
const API_GROUP = "catalyst.catalyst.dev";
const API_VERSION = "v1alpha1";

// Web URL for in-cluster access - can be overridden via env var for different CI setups
const CATALYST_WEB_URL =
  process.env.E2E_CATALYST_WEB_URL ||
  "http://catalyst-web.default.svc.cluster.local:3000";

test.describe("Git Credential Helper via Operator", () => {
  test.slow(); // K8s operations and operator reconciliation can be slow

  test.afterAll(async ({ k8s }) => {
    console.log("Cleaning up git credential helper test resources...");

    // Delete Environment CR first (triggers finalizer to clean up target namespace)
    try {
      await k8s.customApi.deleteNamespacedCustomObject({
        group: API_GROUP,
        version: API_VERSION,
        namespace: TEST_TEAM,
        plural: "environments",
        name: TEST_ENVIRONMENT,
      });
      console.log(`✓ Deleted Environment CR: ${TEST_ENVIRONMENT}`);

      // Wait for namespace deletion (triggered by finalizer)
      const maxWaitMs = 60000;
      const pollIntervalMs = 2000;
      const startTime = Date.now();

      while (Date.now() - startTime < maxWaitMs) {
        try {
          await k8s.coreApi.readNamespace({ name: TARGET_NAMESPACE });
          await new Promise((resolve) => setTimeout(resolve, pollIntervalMs));
        } catch (error) {
          if (error instanceof Error && error.message.includes("not found")) {
            console.log(`✓ Target namespace ${TARGET_NAMESPACE} deleted`);
            break;
          }
          throw error;
        }
      }
    } catch (error) {
      if (error instanceof Error && !error.message.includes("not found")) {
        console.log(`⚠ Failed to delete Environment CR: ${error.message}`);
      }
    }

    // Delete Project CR
    try {
      await k8s.customApi.deleteNamespacedCustomObject({
        group: API_GROUP,
        version: API_VERSION,
        namespace: TEST_TEAM,
        plural: "projects",
        name: TEST_PROJECT,
      });
      console.log(`✓ Deleted Project CR: ${TEST_PROJECT}`);
    } catch (error) {
      if (error instanceof Error && !error.message.includes("not found")) {
        console.log(`⚠ Failed to delete Project CR: ${error.message}`);
      }
    }

    // Delete team namespace (if it still exists and is empty)
    try {
      await k8s.coreApi.deleteNamespace({ name: TEST_TEAM });
      console.log(`✓ Deleted team namespace: ${TEST_TEAM}`);
    } catch (error) {
      if (error instanceof Error && !error.message.includes("not found")) {
        console.log(`⚠ Failed to delete team namespace: ${error.message}`);
      }
    }
  });

  test("should clone repository using operator-created build job with PAT auth", async ({
    k8s,
  }) => {
    console.log("=== Git Credential Helper E2E Test (via Operator) ===");
    console.log(`  Team: ${TEST_TEAM}`);
    console.log(`  Project: ${TEST_PROJECT}`);
    console.log(`  Environment: ${TEST_ENVIRONMENT}`);
    console.log(`  Target Namespace: ${TARGET_NAMESPACE}`);
    console.log(`  Catalyst Web URL: ${CATALYST_WEB_URL}`);
    console.log("");

    // Clean up any existing test resources first
    console.log("Step 0: Cleaning up any existing test resources...");
    await cleanupExistingResources(k8s);

    // Step 1: Create team namespace (Project CR lives here)
    console.log(`Step 1: Creating team namespace '${TEST_TEAM}'...`);
    await k8s.coreApi.createNamespace({
      body: {
        apiVersion: "v1",
        kind: "Namespace",
        metadata: {
          name: TEST_TEAM,
          labels: {
            "catalyst.dev/team": TEST_TEAM,
          },
        },
      },
    });
    console.log(`✓ Team namespace '${TEST_TEAM}' created`);

    // Step 2: Create Project CR in team namespace
    console.log(`Step 2: Creating Project CR '${TEST_PROJECT}'...`);
    await k8s.customApi.createNamespacedCustomObject({
      group: API_GROUP,
      version: API_VERSION,
      namespace: TEST_TEAM,
      plural: "projects",
      body: {
        apiVersion: `${API_GROUP}/${API_VERSION}`,
        kind: "Project",
        metadata: {
          name: TEST_PROJECT,
          namespace: TEST_TEAM,
        },
        spec: {
          // Use "pat" to trigger PAT auth flow (no GitHub App installation)
          githubInstallationId: "pat",
          sources: [
            {
              name: "main",
              repositoryUrl: "https://github.com/ncrmro/catalyst.git",
              branch: "main",
            },
          ],
          templates: {
            // "development" is the key that Environment.spec.type references
            development: {
              type: "helm",
              sourceRef: "main",
              path: "charts/nextjs",
              builds: [
                {
                  name: "web",
                  sourceRef: "main",
                  path: "/web", // Build context within the repo
                },
              ],
            },
          },
        },
      },
    });
    console.log(`✓ Project CR '${TEST_PROJECT}' created`);

    // Step 3: Create Environment CR (triggers operator reconciliation)
    console.log(`Step 3: Creating Environment CR '${TEST_ENVIRONMENT}'...`);
    await k8s.customApi.createNamespacedCustomObject({
      group: API_GROUP,
      version: API_VERSION,
      namespace: TEST_TEAM,
      plural: "environments",
      body: {
        apiVersion: `${API_GROUP}/${API_VERSION}`,
        kind: "Environment",
        metadata: {
          name: TEST_ENVIRONMENT,
          namespace: TEST_TEAM,
          labels: {
            "catalyst.dev/team": TEST_TEAM,
            "catalyst.dev/project": TEST_PROJECT,
            "catalyst.dev/environment": TEST_ENVIRONMENT,
          },
        },
        spec: {
          projectRef: {
            name: TEST_PROJECT,
          },
          type: "development", // References templates["development"]
          sources: [
            {
              name: "main",
              // Must be a valid commit SHA (at least 7 chars) - operator does commitSha[:7]
              commitSha: "c180862e46fca4106fdaf8c044b04ab173a4b914",
              branch: "main",
            },
          ],
        },
      },
    });
    console.log(`✓ Environment CR '${TEST_ENVIRONMENT}' created`);

    // Step 4: Wait for operator to create target namespace
    console.log(
      `Step 4: Waiting for operator to create namespace '${TARGET_NAMESPACE}'...`,
    );
    await waitForNamespace(k8s.coreApi, TARGET_NAMESPACE);
    console.log(`✓ Target namespace '${TARGET_NAMESPACE}' created by operator`);

    // Step 5: Wait for operator to create ConfigMap with git scripts
    console.log(
      "Step 5: Waiting for ConfigMap 'catalyst-git-scripts' to be created...",
    );
    await waitForConfigMap(
      k8s.coreApi,
      TARGET_NAMESPACE,
      "catalyst-git-scripts",
    );
    console.log("✓ ConfigMap 'catalyst-git-scripts' created by operator");

    // Step 6: Wait for operator to create Build Job
    console.log("Step 6: Waiting for Build Job to be created...");
    const jobName = await waitForBuildJob(k8s.batchApi, TARGET_NAMESPACE);
    console.log(`✓ Build Job '${jobName}' created by operator`);

    // Step 7: Wait for Job's pod and check init container status
    console.log(
      "Step 7: Waiting for Build Job pod and checking git-clone init container...",
    );
    const result = await waitForInitContainerCompletion(
      k8s.coreApi,
      TARGET_NAMESPACE,
      jobName,
    );

    // Get init container logs for verification
    console.log("\n=== Init Container (git-clone) Logs ===");
    let logs = "";
    try {
      logs = await k8s.coreApi.readNamespacedPodLog({
        name: result.podName,
        namespace: TARGET_NAMESPACE,
        container: "git-clone",
      });
      console.log(logs);
    } catch (error) {
      console.log(
        `Failed to get logs: ${error instanceof Error ? error.message : error}`,
      );
    }
    console.log("=== End Logs ===\n");

    // Verify init container succeeded
    expect(result.exitCode).toBe(0);
    console.log("✓ Init container 'git-clone' completed with exit code 0");

    // Verify the clone was successful by checking logs
    expect(logs).toContain("Repository cloned at commit");
    console.log("✓ Git credential helper test passed!");
    console.log("  - Operator created ConfigMap with embedded git scripts");
    console.log("  - Operator created Build Job with correct configuration");
    console.log(
      "  - Git credential helper authenticated via /api/git-token/pat",
    );
    console.log("  - Repository clone succeeded");
  });
});

/**
 * Clean up any existing test resources from previous runs
 */
async function cleanupExistingResources(k8s: {
  coreApi: CoreV1Api;
  customApi: CustomObjectsApi;
}): Promise<void> {
  // Delete Environment CR
  try {
    await k8s.customApi.deleteNamespacedCustomObject({
      group: API_GROUP,
      version: API_VERSION,
      namespace: TEST_TEAM,
      plural: "environments",
      name: TEST_ENVIRONMENT,
    });
    // Wait briefly for finalizer to clean up
    await new Promise((resolve) => setTimeout(resolve, 5000));
  } catch {
    // Doesn't exist, that's fine
  }

  // Delete Project CR
  try {
    await k8s.customApi.deleteNamespacedCustomObject({
      group: API_GROUP,
      version: API_VERSION,
      namespace: TEST_TEAM,
      plural: "projects",
      name: TEST_PROJECT,
    });
  } catch {
    // Doesn't exist, that's fine
  }

  // Delete target namespace if it still exists
  try {
    await k8s.coreApi.deleteNamespace({ name: TARGET_NAMESPACE });
    // Wait for namespace to be deleted
    await new Promise((resolve) => setTimeout(resolve, 5000));
  } catch {
    // Doesn't exist, that's fine
  }

  // Delete team namespace if it exists
  try {
    await k8s.coreApi.deleteNamespace({ name: TEST_TEAM });
    // Wait for namespace to be deleted
    await new Promise((resolve) => setTimeout(resolve, 3000));
  } catch {
    // Doesn't exist, that's fine
  }
}

/**
 * Wait for a namespace to be created
 */
async function waitForNamespace(
  coreApi: CoreV1Api,
  namespaceName: string,
): Promise<void> {
  const maxWaitMs = 120000; // 2 minutes
  const pollIntervalMs = 3000;
  const startTime = Date.now();

  while (Date.now() - startTime < maxWaitMs) {
    try {
      await coreApi.readNamespace({ name: namespaceName });
      return; // Namespace exists
    } catch (error) {
      if (error instanceof Error && error.message.includes("not found")) {
        // Keep waiting
        await new Promise((resolve) => setTimeout(resolve, pollIntervalMs));
        continue;
      }
      throw error;
    }
  }

  throw new Error(
    `Timeout waiting for namespace '${namespaceName}' to be created`,
  );
}

/**
 * Wait for a ConfigMap to be created
 */
async function waitForConfigMap(
  coreApi: CoreV1Api,
  namespace: string,
  name: string,
): Promise<void> {
  const maxWaitMs = 120000;
  const pollIntervalMs = 3000;
  const startTime = Date.now();

  while (Date.now() - startTime < maxWaitMs) {
    try {
      const configMap = await coreApi.readNamespacedConfigMap({
        name,
        namespace,
      });

      // Verify it has the expected scripts
      const data = configMap.data || {};
      if (data["git-credential-catalyst.sh"] && data["git-clone.sh"]) {
        return; // ConfigMap exists with expected data
      }
    } catch (error) {
      if (error instanceof Error && error.message.includes("not found")) {
        await new Promise((resolve) => setTimeout(resolve, pollIntervalMs));
        continue;
      }
      throw error;
    }

    await new Promise((resolve) => setTimeout(resolve, pollIntervalMs));
  }

  throw new Error(
    `Timeout waiting for ConfigMap '${name}' in namespace '${namespace}'`,
  );
}

/**
 * Wait for a Build Job to be created and return its name
 * Job name format: build-{buildName}-{commitSha[:7]}
 */
async function waitForBuildJob(
  batchApi: BatchV1Api,
  namespace: string,
): Promise<string> {
  const maxWaitMs = 120000;
  const pollIntervalMs = 3000;
  const startTime = Date.now();

  while (Date.now() - startTime < maxWaitMs) {
    try {
      // List all jobs in the namespace with label selector
      const response = await batchApi.listNamespacedJob({
        namespace,
        labelSelector: "catalyst.dev/job-type=build",
      });

      if (response.items && response.items.length > 0) {
        // Return the first build job found (there should only be one)
        const jobName = response.items[0].metadata?.name;
        if (jobName) {
          return jobName;
        }
      }
    } catch {
      // API not ready yet, keep waiting
    }

    await new Promise((resolve) => setTimeout(resolve, pollIntervalMs));
  }

  throw new Error(
    `Timeout waiting for Build Job to be created in namespace '${namespace}'`,
  );
}

/**
 * Wait for the git-clone init container to complete and return its exit code
 */
async function waitForInitContainerCompletion(
  coreApi: CoreV1Api,
  namespace: string,
  jobName: string,
): Promise<{ podName: string; exitCode: number }> {
  const maxWaitMs = 180000; // 3 minutes for git clone
  const pollIntervalMs = 5000;
  const startTime = Date.now();
  let lastStatus = "";

  while (Date.now() - startTime < maxWaitMs) {
    try {
      // List pods for this job
      const response = await coreApi.listNamespacedPod({
        namespace,
        labelSelector: `job-name=${jobName}`,
      });

      if (response.items.length === 0) {
        if (lastStatus !== "waiting-for-pod") {
          console.log("  Waiting for job pod to be created...");
          lastStatus = "waiting-for-pod";
        }
        await new Promise((resolve) => setTimeout(resolve, pollIntervalMs));
        continue;
      }

      const pod = response.items[0];
      const podName = pod.metadata?.name || "";
      const phase = pod.status?.phase || "";

      // Check init container status
      const initContainerStatus = pod.status?.initContainerStatuses?.find(
        (s) => s.name === "git-clone",
      );

      if (initContainerStatus) {
        const state = initContainerStatus.state;

        if (state?.terminated) {
          // Init container finished
          return {
            podName,
            exitCode: state.terminated.exitCode ?? -1,
          };
        }

        if (state?.running) {
          if (lastStatus !== "running") {
            console.log("  Init container 'git-clone' is running...");
            lastStatus = "running";
          }
        } else if (state?.waiting) {
          const reason = state.waiting.reason || "Unknown";
          if (lastStatus !== reason) {
            console.log(`  Init container 'git-clone' waiting: ${reason}`);
            lastStatus = reason;
          }
        }
      } else {
        if (lastStatus !== phase) {
          console.log(`  Pod phase: ${phase}`);
          lastStatus = phase;
        }
      }
    } catch (error) {
      if (error instanceof Error && !error.message.includes("not found")) {
        console.log(`  Error checking pod status: ${error.message}`);
      }
    }

    await new Promise((resolve) => setTimeout(resolve, pollIntervalMs));
  }

  throw new Error(`Timeout waiting for init container 'git-clone' to complete`);
}
