import { test, expect, waitForEnvironmentReady } from "./fixtures/k8s-fixture";
import type { CoreV1Api, CustomObjectsApi } from "@kubernetes/client-node";

/**
 * E2E Test: Operator Reconciliation
 *
 * This test validates the FULL operator reconciliation flow:
 * 1. Project CR → defines sources and build templates
 * 2. Environment CR → triggers operator reconciliation
 * 3. Operator creates target namespace, ConfigMap, Build Job
 * 4. Build Job clones repo using git credential helper
 * 5. Operator deploys Helm chart with built image
 * 6. Environment CR reaches "Ready" status
 *
 * This test consolidates the North Star integration tests into
 * a single TypeScript E2E test that runs in the existing Playwright suite.
 */

// Test configuration
const TEST_TEAM = "e2e-test";
const TEST_PROJECT = "e2e-operator-test";
const TEST_ENVIRONMENT = "e2e-operator-env";

// Target namespace generated by operator: team-project-environment
const TARGET_NAMESPACE = `${TEST_TEAM}-${TEST_PROJECT}-${TEST_ENVIRONMENT}`;

// API constants for custom resources
const API_GROUP = "catalyst.catalyst.dev";
const API_VERSION = "v1alpha1";

test.describe("Operator Reconciliation", () => {
  test.slow(); // K8s operations and operator reconciliation can be slow
  test.setTimeout(960000); // 16 minutes for full operator reconciliation including build

  test.afterAll(async ({ k8s }) => {
    console.log("Cleaning up operator reconciliation test resources...");

    // Delete Environment CR first (triggers finalizer to clean up target namespace)
    try {
      await k8s.customApi.deleteNamespacedCustomObject({
        group: API_GROUP,
        version: API_VERSION,
        namespace: TEST_TEAM,
        plural: "environments",
        name: TEST_ENVIRONMENT,
      });
      console.log(`✓ Deleted Environment CR: ${TEST_ENVIRONMENT}`);

      // Wait for namespace deletion (triggered by finalizer)
      const maxWaitMs = 60000;
      const pollIntervalMs = 2000;
      const startTime = Date.now();

      while (Date.now() - startTime < maxWaitMs) {
        try {
          await k8s.coreApi.readNamespace({ name: TARGET_NAMESPACE });
          await new Promise((resolve) => setTimeout(resolve, pollIntervalMs));
        } catch (error) {
          if (error instanceof Error && error.message.includes("not found")) {
            console.log(`✓ Target namespace ${TARGET_NAMESPACE} deleted`);
            break;
          }
          throw error;
        }
      }
    } catch (error) {
      if (error instanceof Error && !error.message.includes("not found")) {
        console.log(`⚠ Failed to delete Environment CR: ${error.message}`);
      }
    }

    // Delete Project CR
    try {
      await k8s.customApi.deleteNamespacedCustomObject({
        group: API_GROUP,
        version: API_VERSION,
        namespace: TEST_TEAM,
        plural: "projects",
        name: TEST_PROJECT,
      });
      console.log(`✓ Deleted Project CR: ${TEST_PROJECT}`);
    } catch (error) {
      if (error instanceof Error && !error.message.includes("not found")) {
        console.log(`⚠ Failed to delete Project CR: ${error.message}`);
      }
    }

    // Delete team namespace (if it still exists and is empty)
    try {
      await k8s.coreApi.deleteNamespace({ name: TEST_TEAM });
      console.log(`✓ Deleted team namespace: ${TEST_TEAM}`);
    } catch (error) {
      if (error instanceof Error && !error.message.includes("not found")) {
        console.log(`⚠ Failed to delete team namespace: ${error.message}`);
      }
    }
  });

  test("should reconcile Environment to Ready status with Catalyst development deployment", async ({
    k8s,
  }) => {
    console.log("=== Operator Reconciliation E2E Test ===");
    console.log(`  Team: ${TEST_TEAM}`);
    console.log(`  Project: ${TEST_PROJECT}`);
    console.log(`  Environment: ${TEST_ENVIRONMENT}`);
    console.log(`  Target Namespace: ${TARGET_NAMESPACE}`);
    console.log("");

    // Clean up any existing test resources first
    console.log("Step 0: Cleaning up any existing test resources...");
    await cleanupExistingResources(k8s);

    // Step 1: Create team namespace (Project CR lives here)
    console.log(`Step 1: Creating team namespace '${TEST_TEAM}'...`);
    await k8s.coreApi.createNamespace({
      body: {
        apiVersion: "v1",
        kind: "Namespace",
        metadata: {
          name: TEST_TEAM,
          labels: {
            "catalyst.dev/team": TEST_TEAM,
          },
        },
      },
    });
    console.log(`✓ Team namespace '${TEST_TEAM}' created`);

    // Step 2: Create Project CR in team namespace
    console.log(`Step 2: Creating Project CR '${TEST_PROJECT}'...`);
    await k8s.customApi.createNamespacedCustomObject({
      group: API_GROUP,
      version: API_VERSION,
      namespace: TEST_TEAM,
      plural: "projects",
      body: {
        apiVersion: `${API_GROUP}/${API_VERSION}`,
        kind: "Project",
        metadata: {
          name: TEST_PROJECT,
          namespace: TEST_TEAM,
        },
        spec: {
          // Use "pat" to trigger PAT auth flow (no GitHub App installation)
          githubInstallationId: "pat",
          sources: [
            {
              name: "main",
              // TODO: Replace with hermetic test fixture (local git server) to avoid
              // external dependency on GitHub availability and rate limits.
              repositoryUrl: "https://github.com/ncrmro/catalyst.git",
              branch: "main",
            },
          ],
          templates: {
            // "development" is the key that Environment.spec.type references
            development: {
              type: "helm",
              sourceRef: "main",
              path: "charts/nextjs",
              builds: [
                {
                  name: "web",
                  sourceRef: "main",
                  path: "/web", // Build context within the repo
                },
              ],
            },
          },
        },
      },
    });
    console.log(`✓ Project CR '${TEST_PROJECT}' created`);

    // Step 3: Create Environment CR (triggers operator reconciliation)
    console.log(`Step 3: Creating Environment CR '${TEST_ENVIRONMENT}'...`);
    await k8s.customApi.createNamespacedCustomObject({
      group: API_GROUP,
      version: API_VERSION,
      namespace: TEST_TEAM,
      plural: "environments",
      body: {
        apiVersion: `${API_GROUP}/${API_VERSION}`,
        kind: "Environment",
        metadata: {
          name: TEST_ENVIRONMENT,
          namespace: TEST_TEAM,
          labels: {
            "catalyst.dev/team": TEST_TEAM,
            "catalyst.dev/project": TEST_PROJECT,
            "catalyst.dev/environment": TEST_ENVIRONMENT,
          },
        },
        spec: {
          projectRef: {
            name: TEST_PROJECT,
          },
          type: "development", // References templates["development"]
          sources: [
            {
              name: "main",
              // Must be a valid commit SHA (at least 7 chars) - operator does commitSha[:7]
              commitSha: "c180862e46fca4106fdaf8c044b04ab173a4b914",
              branch: "main",
            },
          ],
        },
      },
    });
    console.log(`✓ Environment CR '${TEST_ENVIRONMENT}' created`);

    // Step 4: Wait for operator to create target namespace
    console.log(
      `Step 4: Waiting for operator to create namespace '${TARGET_NAMESPACE}'...`,
    );
    await waitForNamespace(k8s.coreApi, TARGET_NAMESPACE);
    console.log(`✓ Target namespace '${TARGET_NAMESPACE}' created by operator`);

    // Step 5: Wait for Environment to reach Ready status
    // This validates the full reconciliation: build job → Helm deployment → service ready
    console.log(
      "Step 5: Waiting for Environment to reach Ready status (includes build + deploy)...",
    );
    const result = await waitForEnvironmentReady(
      k8s.customApi,
      TEST_TEAM,
      TEST_ENVIRONMENT,
      { timeoutMs: 540000 }, // 9 minutes (leave 1 minute buffer for test timeout)
    );

    expect(result.phase).toBe("Ready");
    console.log("✓ Environment reached Ready status!");

    // Step 6: Verify the deployment is accessible (if URL is provided)
    console.log("Step 6: Verifying deployment...");

    // Check that pods are running in the target namespace
    const pods = await k8s.coreApi.listNamespacedPod({
      namespace: TARGET_NAMESPACE,
    });
    const runningPods = pods.items.filter(
      (pod) => pod.status?.phase === "Running",
    );
    expect(runningPods.length).toBeGreaterThan(0);
    console.log(
      `✓ Found ${runningPods.length} running pod(s) in ${TARGET_NAMESPACE}`,
    );

    // Log pod names for debugging
    runningPods.forEach((pod) => {
      console.log(`  - ${pod.metadata?.name}`);
    });

    console.log("");
    console.log("=== Operator Reconciliation Test Passed! ===");
    console.log("  ✓ Project CR created with development template");
    console.log("  ✓ Environment CR triggered operator reconciliation");
    console.log("  ✓ Operator created target namespace and resources");
    console.log("  ✓ Build job completed successfully");
    console.log("  ✓ Helm deployment created");
    console.log("  ✓ Environment reached Ready status");
    console.log(`  ✓ Deployment running with ${runningPods.length} pod(s)`);
  });
});

/**
 * Clean up any existing test resources from previous runs
 */
async function cleanupExistingResources(k8s: {
  coreApi: CoreV1Api;
  customApi: CustomObjectsApi;
}): Promise<void> {
  // Delete Environment CR
  try {
    await k8s.customApi.deleteNamespacedCustomObject({
      group: API_GROUP,
      version: API_VERSION,
      namespace: TEST_TEAM,
      plural: "environments",
      name: TEST_ENVIRONMENT,
    });
    // Wait briefly for finalizer to clean up
    await new Promise((resolve) => setTimeout(resolve, 5000));
  } catch {
    // Doesn't exist, that's fine
  }

  // Delete Project CR
  try {
    await k8s.customApi.deleteNamespacedCustomObject({
      group: API_GROUP,
      version: API_VERSION,
      namespace: TEST_TEAM,
      plural: "projects",
      name: TEST_PROJECT,
    });
  } catch {
    // Doesn't exist, that's fine
  }

  // Delete target namespace if it still exists
  try {
    await k8s.coreApi.deleteNamespace({ name: TARGET_NAMESPACE });
    // Wait for namespace to be deleted
    await new Promise((resolve) => setTimeout(resolve, 5000));
  } catch {
    // Doesn't exist, that's fine
  }

  // Delete team namespace if it exists
  try {
    await k8s.coreApi.deleteNamespace({ name: TEST_TEAM });
    // Wait for namespace to be deleted
    await new Promise((resolve) => setTimeout(resolve, 3000));
  } catch {
    // Doesn't exist, that's fine
  }
}

/**
 * Wait for a namespace to be created
 */
async function waitForNamespace(
  coreApi: CoreV1Api,
  namespaceName: string,
): Promise<void> {
  const maxWaitMs = 120000; // 2 minutes
  const pollIntervalMs = 3000;
  const startTime = Date.now();

  while (Date.now() - startTime < maxWaitMs) {
    try {
      await coreApi.readNamespace({ name: namespaceName });
      return; // Namespace exists
    } catch (error) {
      if (error instanceof Error && error.message.includes("not found")) {
        // Keep waiting
        await new Promise((resolve) => setTimeout(resolve, pollIntervalMs));
        continue;
      }
      throw error;
    }
  }

  throw new Error(
    `Timeout waiting for namespace '${namespaceName}' to be created`,
  );
}
